"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/core.js":
/*!************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/core.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlError: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   IntlErrorCode: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   _createCache: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   _createIntlFormatters: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   createFormatter: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createTranslator: () => (/* binding */ createTranslator),\n/* harmony export */   hasLocale: () => (/* binding */ hasLocale),\n/* harmony export */   initializeConfig: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.i)\n/* harmony export */ });\n/* harmony import */ var _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initializeConfig-DPFnvsUO.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\");\n\n\nfunction createTranslatorImpl({\n  messages,\n  namespace,\n  ...rest\n}, namespacePrefix) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix];\n  namespace = (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.r)(namespace, namespacePrefix);\n  return (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.e)({\n    ...rest,\n    messages,\n    namespace\n  });\n}\n\n// This type is slightly more loose than `AbstractIntlMessages`\n// in order to avoid a type error.\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nfunction createTranslator({\n  _cache = (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.d)(),\n  _formatters = (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.b)(_cache),\n  getMessageFallback = _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.f,\n  messages,\n  namespace,\n  onError = _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.g,\n  ...rest\n}) {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  // @ts-expect-error Use the explicit annotation instead\n  return createTranslatorImpl({\n    ...rest,\n    onError,\n    cache: _cache,\n    formatters: _formatters,\n    getMessageFallback,\n    // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n    messages: {\n      '!': messages\n    },\n    namespace: namespace ? `!.${namespace}` : '!'\n  }, '!');\n}\n\n/**\n * Checks if a locale exists in a list of locales.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/Locale\n */\nfunction hasLocale(locales, candidate) {\n  return locales.includes(candidate);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBb007QUFDbkU7QUFLakksU0FBU29CLG9CQUFvQkEsQ0FBQztFQUM1QkMsUUFBUTtFQUNSQyxTQUFTO0VBQ1QsR0FBR0M7QUFDTCxDQUFDLEVBQUVDLGVBQWUsRUFBRTtFQUNsQjtFQUNBO0VBQ0FILFFBQVEsR0FBR0EsUUFBUSxDQUFDRyxlQUFlLENBQUM7RUFDcENGLFNBQVMsR0FBR3JCLGdFQUFnQixDQUFDcUIsU0FBUyxFQUFFRSxlQUFlLENBQUM7RUFDeEQsT0FBT3JCLGdFQUFvQixDQUFDO0lBQzFCLEdBQUdvQixJQUFJO0lBQ1BGLFFBQVE7SUFDUkM7RUFDRixDQUFDLENBQUM7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTRyxnQkFBZ0JBLENBQUM7RUFDeEJDLE1BQU0sR0FBR2pCLGdFQUFXLENBQUMsQ0FBQztFQUN0QmtCLFdBQVcsR0FBR3BCLGdFQUFvQixDQUFDbUIsTUFBTSxDQUFDO0VBQzFDRSxrQkFBa0IsR0FBR3ZCLDREQUF5QjtFQUM5Q2dCLFFBQVE7RUFDUkMsU0FBUztFQUNUTyxPQUFPLEdBQUdsQiw0REFBYztFQUN4QixHQUFHWTtBQUNMLENBQUMsRUFBRTtFQUNEO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBT0gsb0JBQW9CLENBQUM7SUFDMUIsR0FBR0csSUFBSTtJQUNQTSxPQUFPO0lBQ1BDLEtBQUssRUFBRUosTUFBTTtJQUNiSyxVQUFVLEVBQUVKLFdBQVc7SUFDdkJDLGtCQUFrQjtJQUNsQjtJQUNBUCxRQUFRLEVBQUU7TUFDUixHQUFHLEVBQUVBO0lBQ1AsQ0FBQztJQUNEQyxTQUFTLEVBQUVBLFNBQVMsR0FBSSxLQUFJQSxTQUFVLEVBQUMsR0FBRztFQUM1QyxDQUFDLEVBQUUsR0FBRyxDQUFDO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNVLFNBQVNBLENBQUNDLE9BQU8sRUFBRUMsU0FBUyxFQUFFO0VBQ3JDLE9BQU9ELE9BQU8sQ0FBQ0UsUUFBUSxDQUFDRCxTQUFTLENBQUM7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZW50YmFiZS1uZXh0anMtbWlncmF0aW9uLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2NvcmUuanM/NTkxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByIGFzIHJlc29sdmVOYW1lc3BhY2UsIGUgYXMgY3JlYXRlQmFzZVRyYW5zbGF0b3IsIGYgYXMgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjaywgYiBhcyBjcmVhdGVJbnRsRm9ybWF0dGVycywgZCBhcyBjcmVhdGVDYWNoZSwgZyBhcyBkZWZhdWx0T25FcnJvciB9IGZyb20gJy4vaW5pdGlhbGl6ZUNvbmZpZy1EUEZudnNVTy5qcyc7XG5leHBvcnQgeyBJIGFzIEludGxFcnJvciwgYSBhcyBJbnRsRXJyb3JDb2RlLCBjIGFzIGNyZWF0ZUZvcm1hdHRlciwgaSBhcyBpbml0aWFsaXplQ29uZmlnIH0gZnJvbSAnLi9pbml0aWFsaXplQ29uZmlnLURQRm52c1VPLmpzJztcblxuXG5cblxuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvckltcGwoe1xuICBtZXNzYWdlcyxcbiAgbmFtZXNwYWNlLFxuICAuLi5yZXN0XG59LCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgLy8gVGhlIGBuYW1lc3BhY2VQcmVmaXhgIGlzIHBhcnQgb2YgdGhlIHR5cGUgc3lzdGVtLlxuICAvLyBTZWUgdGhlIGNvbW1lbnQgaW4gdGhlIGZ1bmN0aW9uIGludm9jYXRpb24uXG4gIG1lc3NhZ2VzID0gbWVzc2FnZXNbbmFtZXNwYWNlUHJlZml4XTtcbiAgbmFtZXNwYWNlID0gcmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCk7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgLi4ucmVzdCxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2VcbiAgfSk7XG59XG5cbi8vIFRoaXMgdHlwZSBpcyBzbGlnaHRseSBtb3JlIGxvb3NlIHRoYW4gYEFic3RyYWN0SW50bE1lc3NhZ2VzYFxuLy8gaW4gb3JkZXIgdG8gYXZvaWQgYSB0eXBlIGVycm9yLlxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcih7XG4gIF9jYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG4gIF9mb3JtYXR0ZXJzID0gY3JlYXRlSW50bEZvcm1hdHRlcnMoX2NhY2hlKSxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbWVzc2FnZXMsXG4gIG5hbWVzcGFjZSxcbiAgb25FcnJvciA9IGRlZmF1bHRPbkVycm9yLFxuICAuLi5yZXN0XG59KSB7XG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGZ1bmN0aW9uIHNvIHRoZSB0eXBlIGluZmVyZW5jZSBmb3IgdGhlIG9wdGlvbmFsXG4gIC8vIG5hbWVzcGFjZSB3b3JrcyBjb3JyZWN0bHkuIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gIC8vIFRoZSBwcmVmaXggKFwiIVwiKSBpcyBhcmJpdHJhcnkuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3IgVXNlIHRoZSBleHBsaWNpdCBhbm5vdGF0aW9uIGluc3RlYWRcbiAgcmV0dXJuIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5yZXN0LFxuICAgIG9uRXJyb3IsXG4gICAgY2FjaGU6IF9jYWNoZSxcbiAgICBmb3JtYXR0ZXJzOiBfZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgbWVzc2FnZXNgIGlzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAgaGVyZSBhbmQgd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHlcbiAgICBtZXNzYWdlczoge1xuICAgICAgJyEnOiBtZXNzYWdlc1xuICAgIH0sXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UgPyBgIS4ke25hbWVzcGFjZX1gIDogJyEnXG4gIH0sICchJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbG9jYWxlIGV4aXN0cyBpbiBhIGxpc3Qgb2YgbG9jYWxlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludGwvTG9jYWxlXG4gKi9cbmZ1bmN0aW9uIGhhc0xvY2FsZShsb2NhbGVzLCBjYW5kaWRhdGUpIHtcbiAgcmV0dXJuIGxvY2FsZXMuaW5jbHVkZXMoY2FuZGlkYXRlKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2FjaGUgYXMgX2NyZWF0ZUNhY2hlLCBjcmVhdGVJbnRsRm9ybWF0dGVycyBhcyBfY3JlYXRlSW50bEZvcm1hdHRlcnMsIGNyZWF0ZVRyYW5zbGF0b3IsIGhhc0xvY2FsZSB9O1xuIl0sIm5hbWVzIjpbInIiLCJyZXNvbHZlTmFtZXNwYWNlIiwiZSIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiZiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJiIiwiY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJkIiwiY3JlYXRlQ2FjaGUiLCJnIiwiZGVmYXVsdE9uRXJyb3IiLCJJIiwiSW50bEVycm9yIiwiYSIsIkludGxFcnJvckNvZGUiLCJjIiwiY3JlYXRlRm9ybWF0dGVyIiwiaSIsImluaXRpYWxpemVDb25maWciLCJjcmVhdGVUcmFuc2xhdG9ySW1wbCIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwicmVzdCIsIm5hbWVzcGFjZVByZWZpeCIsImNyZWF0ZVRyYW5zbGF0b3IiLCJfY2FjaGUiLCJfZm9ybWF0dGVycyIsImdldE1lc3NhZ2VGYWxsYmFjayIsIm9uRXJyb3IiLCJjYWNoZSIsImZvcm1hdHRlcnMiLCJoYXNMb2NhbGUiLCJsb2NhbGVzIiwiY2FuZGlkYXRlIiwiaW5jbHVkZXMiLCJfY3JlYXRlQ2FjaGUiLCJfY3JlYXRlSW50bEZvcm1hdHRlcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlError: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   IntlErrorCode: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   IntlProvider: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.IntlProvider),\n/* harmony export */   _createCache: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   _createIntlFormatters: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   createFormatter: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createTranslator: () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_1__.createTranslator),\n/* harmony export */   hasLocale: () => (/* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_1__.hasLocale),\n/* harmony export */   initializeConfig: () => (/* reexport safe */ _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   useFormatter: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useFormatter),\n/* harmony export */   useLocale: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useLocale),\n/* harmony export */   useMessages: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useMessages),\n/* harmony export */   useNow: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useNow),\n/* harmony export */   useTimeZone: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useTimeZone),\n/* harmony export */   useTranslations: () => (/* reexport safe */ _react_js__WEBPACK_IMPORTED_MODULE_2__.useTranslations)\n/* harmony export */ });\n/* harmony import */ var _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./initializeConfig-DPFnvsUO.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/core.js\");\n/* harmony import */ var _react_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./react.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/react.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdMO0FBQ3hIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVudGJhYmUtbmV4dGpzLW1pZ3JhdGlvbi8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9pbmRleC5qcz9lZGU4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEkgYXMgSW50bEVycm9yLCBhIGFzIEludGxFcnJvckNvZGUsIGQgYXMgX2NyZWF0ZUNhY2hlLCBiIGFzIF9jcmVhdGVJbnRsRm9ybWF0dGVycywgYyBhcyBjcmVhdGVGb3JtYXR0ZXIsIGkgYXMgaW5pdGlhbGl6ZUNvbmZpZyB9IGZyb20gJy4vaW5pdGlhbGl6ZUNvbmZpZy1EUEZudnNVTy5qcyc7XG5leHBvcnQgeyBjcmVhdGVUcmFuc2xhdG9yLCBoYXNMb2NhbGUgfSBmcm9tICcuL2NvcmUuanMnO1xuZXhwb3J0IHsgSW50bFByb3ZpZGVyLCB1c2VGb3JtYXR0ZXIsIHVzZUxvY2FsZSwgdXNlTWVzc2FnZXMsIHVzZU5vdywgdXNlVGltZVpvbmUsIHVzZVRyYW5zbGF0aW9ucyB9IGZyb20gJy4vcmVhY3QuanMnO1xuXG5cblxuXG4iXSwibmFtZXMiOlsiSSIsIkludGxFcnJvciIsImEiLCJJbnRsRXJyb3JDb2RlIiwiZCIsIl9jcmVhdGVDYWNoZSIsImIiLCJfY3JlYXRlSW50bEZvcm1hdHRlcnMiLCJjIiwiY3JlYXRlRm9ybWF0dGVyIiwiaSIsImluaXRpYWxpemVDb25maWciLCJjcmVhdGVUcmFuc2xhdG9yIiwiaGFzTG9jYWxlIiwiSW50bFByb3ZpZGVyIiwidXNlRm9ybWF0dGVyIiwidXNlTG9jYWxlIiwidXNlTWVzc2FnZXMiLCJ1c2VOb3ciLCJ1c2VUaW1lWm9uZSIsInVzZVRyYW5zbGF0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(ssr)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n  constructor(code, originalMessage) {\n    let message = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\nvar IntlErrorCode = /*#__PURE__*/function (IntlErrorCode) {\n  IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n  IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n  IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n  IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n  IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n  IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n  IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n  return IntlErrorCode;\n}(IntlErrorCode || {});\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nfunction convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n  const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n  const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n  const dateTimeFormats = {\n    ...globalFormats?.dateTime,\n    ...inlineFormats?.dateTime\n  };\n  const allFormats = {\n    date: {\n      ...mfDateDefaults,\n      ...dateTimeFormats\n    },\n    time: {\n      ...mfTimeDefaults,\n      ...dateTimeFormats\n    },\n    number: {\n      ...globalFormats?.number,\n      ...inlineFormats?.number\n    }\n    // (list is not supported in ICU messages)\n  };\n\n  if (timeZone) {\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    ['date', 'time'].forEach(property => {\n      const formats = allFormats[property];\n      for (const [key, value] of Object.entries(formats)) {\n        formats[key] = {\n          timeZone,\n          ...value\n        };\n      }\n    });\n  }\n  return allFormats;\n}\nfunction joinPath(...parts) {\n  return parts.filter(Boolean).join('.');\n}\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nfunction defaultGetMessageFallback(props) {\n  return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n  console.error(error);\n}\nfunction createCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\nfunction createMemoCache(store) {\n  return {\n    create() {\n      return {\n        get(key) {\n          return store[key];\n        },\n        set(key, value) {\n          store[key] = value;\n        }\n      };\n    }\n  };\n}\nfunction memoFn(fn, cache) {\n  return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n    cache: createMemoCache(cache),\n    strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n  });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n  return memoFn((...args) => new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n  const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n  const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n  const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n  const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n  const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n  const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n  return {\n    getDateTimeFormat,\n    getNumberFormat,\n    getPluralRules,\n    getRelativeTimeFormat,\n    getListFormat,\n    getDisplayNames\n  };\n}\n\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n  const getMessageFormat = memoFn((...args) => new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n    formatters: intlFormatters,\n    ...args[3]\n  }), cache.message);\n  return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n  const fullKey = joinPath(namespace, key);\n  if (!messages) {\n    throw new Error(`No messages available at \\`${namespace}\\`.`);\n  }\n  let message = messages;\n  key.split('.').forEach(part => {\n    const next = message[part];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (part == null || next == null) {\n      throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n    }\n    message = next;\n  });\n  return message;\n}\nfunction prepareTranslationValues(values) {\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues = {};\n  Object.keys(values).forEach(key => {\n    let index = 0;\n    const value = values[key];\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = chunks => {\n        const result = value(chunks);\n        return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n          key: key + index++\n        }) : result;\n      };\n    } else {\n      transformed = value;\n    }\n    transformedValues[key] = transformed;\n  });\n  return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace, onError = defaultOnError) {\n  try {\n    if (!messages) {\n      throw new Error(`No messages were configured.`);\n    }\n    const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!retrievedMessages) {\n      throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n    }\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n    onError(intlError);\n    return intlError;\n  }\n}\nfunction getPlainMessage(candidate, values) {\n  // To improve runtime performance, only compile message if:\n  return (\n    // 1. Values are provided\n    values ||\n    // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) ||\n    // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n    : candidate // Don't compile\n  );\n}\n\nfunction createBaseTranslator(config) {\n  const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n  return createBaseTranslatorImpl({\n    ...config,\n    messagesOrError\n  });\n}\nfunction createBaseTranslatorImpl({\n  cache,\n  formats: globalFormats,\n  formatters,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}) {\n  const hasMessagesError = messagesOrError instanceof IntlError;\n  function getFallbackFromErrorAndNotify(key, code, message) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({\n      error,\n      key,\n      namespace\n    });\n  }\n  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    let message;\n    try {\n      message = resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n    if (typeof message === 'object') {\n      let code, errorMessage;\n      if (Array.isArray(message)) {\n        code = IntlErrorCode.INVALID_MESSAGE;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages`;\n        }\n      } else {\n        code = IntlErrorCode.INSUFFICIENT_PATH;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages`;\n        }\n      }\n      return getFallbackFromErrorAndNotify(key, code, errorMessage);\n    }\n    let messageFormat;\n\n    // Hot path that avoids creating an `IntlMessageFormat` instance\n    const plainMessage = getPlainMessage(message, values);\n    if (plainMessage) return plainMessage;\n\n    // Lazy init the message formatter for better tree\n    // shaking in case message formatting is not used.\n    if (!formatters.getMessageFormat) {\n      formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n    }\n    try {\n      messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n        formatters: {\n          ...formatters,\n          getDateTimeFormat(locales, options) {\n            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n            return formatters.getDateTimeFormat(locales, {\n              timeZone,\n              ...options\n            });\n          }\n        }\n      });\n    } catch (error) {\n      const thrownError = error;\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + ('originalMessage' in thrownError ? ` (${thrownError.originalMessage})` : ''));\n    }\n    try {\n      const formattedMessage = messageFormat.format(\n      // @ts-expect-error `intl-messageformat` expects a different format\n      // for rich text elements since a recent minor update. This\n      // needs to be evaluated in detail, possibly also in regards\n      // to be able to format to parts.\n      values ? prepareTranslationValues(values) : values);\n      if (formattedMessage == null) {\n        throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'}`);\n      }\n\n      // Limit the function signature to return strings or React elements\n      return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) ||\n      // Arrays of React elements\n      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);\n    }\n  }\n  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    const result = translateBaseFn(key, values, formats);\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n    }\n    return result;\n  }\n  translateFn.rich = translateBaseFn;\n\n  // Augment `translateBaseFn` to return plain strings\n  translateFn.markup = (key, values, formats) => {\n    const result = translateBaseFn(key,\n    // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n    // of `RichTranslationValues` but TypeScript isn't smart enough here.\n    values, formats);\n    if (typeof result !== 'string') {\n      const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n      onError(error);\n      return getMessageFallback({\n        error,\n        key,\n        namespace\n      });\n    }\n    return result;\n  };\n  translateFn.raw = key => {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    try {\n      return resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n  };\n  translateFn.has = key => {\n    if (hasMessagesError) {\n      return false;\n    }\n    try {\n      resolvePath(locale, messagesOrError, key, namespace);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  return translateFn;\n}\n\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nfunction resolveNamespace(namespace, namespacePrefix) {\n  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n  const absValue = Math.abs(seconds);\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n  const {\n    _cache: cache = createCache(),\n    _formatters: formatters = createIntlFormatters(cache),\n    formats,\n    locale,\n    onError = defaultOnError,\n    timeZone: globalTimeZone\n  } = props;\n  function applyTimeZone(options) {\n    if (!options?.timeZone) {\n      if (globalTimeZone) {\n        options = {\n          ...options,\n          timeZone: globalTimeZone\n        };\n      } else {\n        onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n      }\n    }\n    return options;\n  }\n  function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n      if (!options) {\n        const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n    if (overrides) {\n      options = {\n        ...options,\n        ...overrides\n      };\n    }\n    return options;\n  }\n  function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n    } catch {\n      return getFallback();\n    }\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return getFallback();\n    }\n  }\n  function dateTime(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).format(value);\n    }, () => String(value));\n  }\n  function dateTimeRange(start, end, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n    }, () => [dateTime(start), dateTime(end)].join(' – '));\n  }\n  function number(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.number, options => formatters.getNumberFormat(locale, options).format(value), () => String(value));\n  }\n  function getGlobalNow() {\n    // Only read when necessary to avoid triggering a `dynamicIO` error\n    // unnecessarily (`now` is only needed for `format.relativeTime`)\n    if (props.now) {\n      return props.now;\n    } else {\n      onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n      return new Date();\n    }\n  }\n  function relativeTime(date, nowOrOptions) {\n    try {\n      let nowDate, unit;\n      const opts = {};\n      if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n        nowDate = new Date(nowOrOptions);\n      } else if (nowOrOptions) {\n        if (nowOrOptions.now != null) {\n          nowDate = new Date(nowOrOptions.now);\n        } else {\n          nowDate = getGlobalNow();\n        }\n        unit = nowOrOptions.unit;\n        opts.style = nowOrOptions.style;\n        // @ts-expect-error -- Types are slightly outdated\n        opts.numberingSystem = nowOrOptions.numberingSystem;\n      }\n      if (!nowDate) {\n        nowDate = getGlobalNow();\n      }\n      const dateDate = new Date(date);\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      if (!unit) {\n        unit = resolveRelativeTimeUnit(seconds);\n      }\n\n      // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n      // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n      // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n      // not desired, as the given dates might cross a threshold were the\n      // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n      // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n      // case. By using `always` we can ensure correct output. The only exception\n      // is the formatting of times <1 second as \"now\".\n      opts.numeric = unit === 'second' ? 'auto' : 'always';\n      const value = calculateRelativeTimeValue(seconds, unit);\n      return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(date);\n    }\n  }\n  function list(value, formatOrOptions, overrides) {\n    const serializedValue = [];\n    const richValues = new Map();\n\n    // `formatToParts` only accepts strings, therefore we have to temporarily\n    // replace React elements with a placeholder ID that can be used to retrieve\n    // the original value afterwards.\n    let index = 0;\n    for (const item of value) {\n      let serializedItem;\n      if (typeof item === 'object') {\n        serializedItem = String(index);\n        richValues.set(serializedItem, item);\n      } else {\n        serializedItem = String(item);\n      }\n      serializedValue.push(serializedItem);\n      index++;\n    }\n    return getFormattedValue(formatOrOptions, overrides, formats?.list,\n    // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n    options => {\n      const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map(part => part.type === 'literal' ? part.value : richValues.get(part.value) || part.value);\n      if (richValues.size > 0) {\n        return result;\n      } else {\n        return result.join('');\n      }\n    }, () => String(value));\n  }\n  return {\n    dateTime,\n    number,\n    relativeTime,\n    list,\n    dateTimeRange\n  };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n  Object.entries(messages).forEach(([key, messageOrMessages]) => {\n    if (key.includes('.')) {\n      let keyLabel = key;\n      if (parentPath) keyLabel += ` (at ${parentPath})`;\n      invalidKeyLabels.push(keyLabel);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (messageOrMessages != null && typeof messageOrMessages === 'object') {\n      validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n    }\n  });\n}\nfunction validateMessages(messages, onError) {\n  const invalidKeyLabels = [];\n  validateMessagesSegment(messages, invalidKeyLabels);\n  if (invalidKeyLabels.length > 0) {\n    onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? 'key' : 'keys'}: ${invalidKeyLabels.join(', ')}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n  }\n}\n\n/**\n * Enhances the incoming props with defaults.\n */\nfunction initializeConfig({\n  formats,\n  getMessageFallback,\n  messages,\n  onError,\n  ...rest\n}) {\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n  {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n  return {\n    ...rest,\n    formats: formats || undefined,\n    messages: messages || undefined,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1EUEZudnNVTy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxTQUFTLFNBQVNDLEtBQUssQ0FBQztFQUM1QkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxlQUFlLEVBQUU7SUFDakMsSUFBSUMsT0FBTyxHQUFHRixJQUFJO0lBQ2xCLElBQUlDLGVBQWUsRUFBRTtNQUNuQkMsT0FBTyxJQUFJLElBQUksR0FBR0QsZUFBZTtJQUNuQztJQUNBLEtBQUssQ0FBQ0MsT0FBTyxDQUFDO0lBQ2QsSUFBSSxDQUFDRixJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSUMsZUFBZSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxlQUFlO0lBQ3hDO0VBQ0Y7QUFDRjtBQUVBLElBQUlFLGFBQWEsR0FBRyxhQUFhLFVBQVVBLGFBQWEsRUFBRTtFQUN4REEsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsaUJBQWlCO0VBQ3BEQSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxnQkFBZ0I7RUFDbERBLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLHNCQUFzQjtFQUM5REEsYUFBYSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsbUJBQW1CO0VBQ3hEQSxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxpQkFBaUI7RUFDcERBLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxhQUFhO0VBQzVDQSxhQUFhLENBQUMsa0JBQWtCLENBQUMsR0FBRyxrQkFBa0I7RUFDdEQsT0FBT0EsYUFBYTtBQUN0QixDQUFDLENBQUNBLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxpQ0FBaUNBLENBQUNDLGFBQWEsRUFBRUMsYUFBYSxF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YmFiZS1uZXh0anMtbWlncmF0aW9uLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctRFBGbnZzVU8uanM/YmI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRsTWVzc2FnZUZvcm1hdCB9IGZyb20gJ2ludGwtbWVzc2FnZWZvcm1hdCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVtb2l6ZSwgc3RyYXRlZ2llcyB9IGZyb20gJ0Bmb3JtYXRqcy9mYXN0LW1lbW9pemUnO1xuXG5jbGFzcyBJbnRsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbnZhciBJbnRsRXJyb3JDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChJbnRsRXJyb3JDb2RlKSB7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX01FU1NBR0VcIl0gPSBcIk1JU1NJTkdfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19GT1JNQVRcIl0gPSBcIk1JU1NJTkdfRk9STUFUXCI7XG4gIEludGxFcnJvckNvZGVbXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiXSA9IFwiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9QQVRIXCJdID0gXCJJTlNVRkZJQ0lFTlRfUEFUSFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVNTQUdFXCJdID0gXCJJTlZBTElEX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfS0VZXCJdID0gXCJJTlZBTElEX0tFWVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRk9STUFUVElOR19FUlJPUlwiXSA9IFwiRk9STUFUVElOR19FUlJPUlwiO1xuICByZXR1cm4gSW50bEVycm9yQ29kZTtcbn0oSW50bEVycm9yQ29kZSB8fCB7fSk7XG5cbi8qKlxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcbiAqIG9ubHkgb25lIG5hdGl2ZSBBUEk6IGBJbnRsLkRhdGVUaW1lRm9ybWF0YC4gQWRkaXRpb25hbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiBpbmNsdWRlIGJvdGggYSB0aW1lIGFuZCBhIGRhdGUgaW4gYSB2YWx1ZSwgdGhlcmVmb3JlIHRoZSBzZXBhcmF0aW9uIGRvZXNuJ3RcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxuICogdG8gY29udmVydCB0aGUgZm9ybWF0IGJlZm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGlubGluZUZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGNvbnN0IG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy5kYXRlO1xuICBjb25zdCBtZlRpbWVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMudGltZTtcbiAgY29uc3QgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICAgIC4uLmdsb2JhbEZvcm1hdHM/LmRhdGVUaW1lLFxuICAgIC4uLmlubGluZUZvcm1hdHM/LmRhdGVUaW1lXG4gIH07XG4gIGNvbnN0IGFsbEZvcm1hdHMgPSB7XG4gICAgZGF0ZToge1xuICAgICAgLi4ubWZEYXRlRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIHRpbWU6IHtcbiAgICAgIC4uLm1mVGltZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIC4uLmdsb2JhbEZvcm1hdHM/Lm51bWJlcixcbiAgICAgIC4uLmlubGluZUZvcm1hdHM/Lm51bWJlclxuICAgIH1cbiAgICAvLyAobGlzdCBpcyBub3Qgc3VwcG9ydGVkIGluIElDVSBtZXNzYWdlcylcbiAgfTtcbiAgaWYgKHRpbWVab25lKSB7XG4gICAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvYmxvYi84MjU2YzUyNzE1MDVjZjI2MDZlNDhlM2M5N2VjZGQxNmVkZTRmMWI1L3BhY2thZ2VzL2ludGwvc3JjL21lc3NhZ2UudHMjTDE1XG4gICAgWydkYXRlJywgJ3RpbWUnXS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSBhbGxGb3JtYXRzW3Byb3BlcnR5XTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcm1hdHMpKSB7XG4gICAgICAgIGZvcm1hdHNba2V5XSA9IHtcbiAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhbGxGb3JtYXRzO1xufVxuXG5mdW5jdGlvbiBqb2luUGF0aCguLi5wYXJ0cykge1xuICByZXR1cm4gcGFydHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBkZWZhdWx0cyB0aGF0IGFyZSB1c2VkIGZvciBhbGwgZW50cnkgcG9pbnRzIGludG8gdGhlIGNvcmUuXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gam9pblBhdGgocHJvcHMubmFtZXNwYWNlLCBwcm9wcy5rZXkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICByZXR1cm4ge1xuICAgIGRhdGVUaW1lOiB7fSxcbiAgICBudW1iZXI6IHt9LFxuICAgIG1lc3NhZ2U6IHt9LFxuICAgIHJlbGF0aXZlVGltZToge30sXG4gICAgcGx1cmFsUnVsZXM6IHt9LFxuICAgIGxpc3Q6IHt9LFxuICAgIGRpc3BsYXlOYW1lczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9DYWNoZShzdG9yZSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWVtb0ZuKGZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb2l6ZShmbiwge1xuICAgIGNhY2hlOiBjcmVhdGVNZW1vQ2FjaGUoY2FjaGUpLFxuICAgIHN0cmF0ZWd5OiBzdHJhdGVnaWVzLnZhcmlhZGljXG4gIH0pO1xufVxuZnVuY3Rpb24gbWVtb0NvbnN0cnVjdG9yKENvbnN0cnVjdG9yRm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBDb25zdHJ1Y3RvckZuKC4uLmFyZ3MpLCBjYWNoZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSkge1xuICBjb25zdCBnZXREYXRlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRhdGVUaW1lRm9ybWF0LCBjYWNoZS5kYXRlVGltZSk7XG4gIGNvbnN0IGdldE51bWJlckZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLk51bWJlckZvcm1hdCwgY2FjaGUubnVtYmVyKTtcbiAgY29uc3QgZ2V0UGx1cmFsUnVsZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5QbHVyYWxSdWxlcywgY2FjaGUucGx1cmFsUnVsZXMpO1xuICBjb25zdCBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQsIGNhY2hlLnJlbGF0aXZlVGltZSk7XG4gIGNvbnN0IGdldExpc3RGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5MaXN0Rm9ybWF0LCBjYWNoZS5saXN0KTtcbiAgY29uc3QgZ2V0RGlzcGxheU5hbWVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGlzcGxheU5hbWVzLCBjYWNoZS5kaXNwbGF5TmFtZXMpO1xuICByZXR1cm4ge1xuICAgIGdldERhdGVUaW1lRm9ybWF0LFxuICAgIGdldE51bWJlckZvcm1hdCxcbiAgICBnZXRQbHVyYWxSdWxlcyxcbiAgICBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TGlzdEZvcm1hdCxcbiAgICBnZXREaXNwbGF5TmFtZXNcbiAgfTtcbn1cblxuLy8gUGxhY2VkIGhlcmUgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZy4gU29tZWhvdyB3aGVuIHRoaXMgaXMgcGxhY2VkIGluXG4vLyBgZm9ybWF0dGVycy50c3hgLCB0aGVuIGl0IGNhbid0IGJlIHNoYWtlbiBvZmYgZnJvbSBgbmV4dC1pbnRsYC5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGludGxGb3JtYXR0ZXJzKSB7XG4gIGNvbnN0IGdldE1lc3NhZ2VGb3JtYXQgPSBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBJbnRsTWVzc2FnZUZvcm1hdChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCB7XG4gICAgZm9ybWF0dGVyczogaW50bEZvcm1hdHRlcnMsXG4gICAgLi4uYXJnc1szXVxuICB9KSwgY2FjaGUubWVzc2FnZSk7XG4gIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KTtcbiAgaWYgKCFtZXNzYWdlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IFxcYCR7bmFtZXNwYWNlfVxcYC5gICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgXFxgJHtmdWxsS2V5fVxcYCBpbiBtZXNzYWdlcyBmb3IgbG9jYWxlIFxcYCR7bG9jYWxlfVxcYC5gICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMTQ2N1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gY2h1bmtzID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoY2h1bmtzKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChyZXN1bHQpID8gLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlLCBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZC5gICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGZvciBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgIGZvdW5kLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJpZXZlZE1lc3NhZ2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGludGxFcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoaW50bEVycm9yKTtcbiAgICByZXR1cm4gaW50bEVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFpbk1lc3NhZ2UoY2FuZGlkYXRlLCB2YWx1ZXMpIHtcbiAgLy8gVG8gaW1wcm92ZSBydW50aW1lIHBlcmZvcm1hbmNlLCBvbmx5IGNvbXBpbGUgbWVzc2FnZSBpZjpcbiAgcmV0dXJuIChcbiAgICAvLyAxLiBWYWx1ZXMgYXJlIHByb3ZpZGVkXG4gICAgdmFsdWVzIHx8XG4gICAgLy8gMi4gVGhlcmUgYXJlIGVzY2FwZWQgYnJhY2VzIChlLmcuIFwiJ3tuYW1lJ31cIilcbiAgICAvJ1t7fV0vLnRlc3QoY2FuZGlkYXRlKSB8fFxuICAgIC8vIDMuIFRoZXJlIGFyZSBtaXNzaW5nIGFyZ3VtZW50cyBvciB0YWdzIChkZXYtb25seSBlcnJvciBoYW5kbGluZylcbiAgICAvPHx7Ly50ZXN0KGNhbmRpZGF0ZSkgPyB1bmRlZmluZWQgLy8gQ29tcGlsZVxuICAgIDogY2FuZGlkYXRlIC8vIERvbid0IGNvbXBpbGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICBjYWNoZSxcbiAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgZm9ybWF0dGVycyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbG9jYWxlLFxuICBtZXNzYWdlc09yRXJyb3IsXG4gIG5hbWVzcGFjZSxcbiAgb25FcnJvcixcbiAgdGltZVpvbmVcbn0pIHtcbiAgY29uc3QgaGFzTWVzc2FnZXNFcnJvciA9IG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIEludGxFcnJvcjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKGNvZGUsIG1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgZXJyb3IsXG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlID0gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBjb2RlLCBlcnJvck1lc3NhZ2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgTWVzc2FnZSBhdCBcXGAke2pvaW5QYXRoKG5hbWVzcGFjZSwga2V5KX1cXGAgcmVzb2x2ZWQgdG8gYW4gYXJyYXksIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL21lc3NhZ2VzI2FycmF5cy1vZi1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOU1VGRklDSUVOVF9QQVRIO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBcXGAuXFxgIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL21lc3NhZ2VzI3N0cnVjdHVyaW5nLW1lc3NhZ2VzYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2VGb3JtYXQ7XG5cbiAgICAvLyBIb3QgcGF0aCB0aGF0IGF2b2lkcyBjcmVhdGluZyBhbiBgSW50bE1lc3NhZ2VGb3JtYXRgIGluc3RhbmNlXG4gICAgY29uc3QgcGxhaW5NZXNzYWdlID0gZ2V0UGxhaW5NZXNzYWdlKG1lc3NhZ2UsIHZhbHVlcyk7XG4gICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcblxuICAgIC8vIExhenkgaW5pdCB0aGUgbWVzc2FnZSBmb3JtYXR0ZXIgZm9yIGJldHRlciB0cmVlXG4gICAgLy8gc2hha2luZyBpbiBjYXNlIG1lc3NhZ2UgZm9ybWF0dGluZyBpcyBub3QgdXNlZC5cbiAgICBpZiAoIWZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCkge1xuICAgICAgZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0ID0gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgZm9ybWF0dGVycyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlRm9ybWF0ID0gZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0KG1lc3NhZ2UsIGxvY2FsZSwgY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGZvcm1hdHMsIHRpbWVab25lKSwge1xuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgLi4uZm9ybWF0dGVycyxcbiAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgdGhyb3duRXJyb3IubWVzc2FnZSArICgnb3JpZ2luYWxNZXNzYWdlJyBpbiB0aHJvd25FcnJvciA/IGAgKCR7dGhyb3duRXJyb3Iub3JpZ2luYWxNZXNzYWdlfSlgIDogJycpICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZUZvcm1hdC5mb3JtYXQoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGV4cGVjdHMgYSBkaWZmZXJlbnQgZm9ybWF0XG4gICAgICAvLyBmb3IgcmljaCB0ZXh0IGVsZW1lbnRzIHNpbmNlIGEgcmVjZW50IG1pbm9yIHVwZGF0ZS4gVGhpc1xuICAgICAgLy8gbmVlZHMgdG8gYmUgZXZhbHVhdGVkIGluIGRldGFpbCwgcG9zc2libHkgYWxzbyBpbiByZWdhcmRzXG4gICAgICAvLyB0byBiZSBhYmxlIHRvIGZvcm1hdCB0byBwYXJ0cy5cbiAgICAgIHZhbHVlcyA/IHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIDogdmFsdWVzKTtcbiAgICAgIGlmIChmb3JtYXR0ZWRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZm9ybWF0IFxcYCR7a2V5fVxcYCBpbiAke25hbWVzcGFjZSA/IGBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgYCA6ICdtZXNzYWdlcyd9YCApO1xuICAgICAgfVxuXG4gICAgICAvLyBMaW1pdCB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHRvIHJldHVybiBzdHJpbmdzIG9yIFJlYWN0IGVsZW1lbnRzXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KGZvcm1hdHRlZE1lc3NhZ2UpIHx8XG4gICAgICAvLyBBcnJheXMgb2YgUmVhY3QgZWxlbWVudHNcbiAgICAgIEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkTWVzc2FnZSkgfHwgdHlwZW9mIGZvcm1hdHRlZE1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZm9ybWF0dGVkTWVzc2FnZSA6IFN0cmluZyhmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIGBUaGUgbWVzc2FnZSBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfSBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIFxcYHQucmljaFxcYCBpbnN0ZWFkLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuXG4gIC8vIEF1Z21lbnQgYHRyYW5zbGF0ZUJhc2VGbmAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKGtleSwgdmFsdWVzLCBmb3JtYXRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGBNYXJrdXBUcmFuc2xhdGlvblZhbHVlc2AgaXMgcHJhY3RpY2FsbHkgYSBzdWIgdHlwZVxuICAgIC8vIG9mIGBSaWNoVHJhbnNsYXRpb25WYWx1ZXNgIGJ1dCBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCBoZXJlLlxuICAgIHZhbHVlcywgZm9ybWF0cyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgdHJhbnNsYXRlRm4uaGFzID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlc09yRXJyb3IsIGtleSwgbmFtZXNwYWNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG4vKipcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXG4gKiBhIG1hbmRhdG9yeSBwcmVmaXguIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlUHJlZml4ID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlLnNsaWNlKChuYW1lc3BhY2VQcmVmaXggKyAnLicpLmxlbmd0aCk7XG59XG5cbmNvbnN0IFNFQ09ORCA9IDE7XG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmNvbnN0IERBWSA9IEhPVVIgKiAyNDtcbmNvbnN0IFdFRUsgPSBEQVkgKiA3O1xuY29uc3QgTU9OVEggPSBEQVkgKiAoMzY1IC8gMTIpOyAvLyBBcHByb3hpbWF0aW9uXG5jb25zdCBRVUFSVEVSID0gTU9OVEggKiAzO1xuY29uc3QgWUVBUiA9IERBWSAqIDM2NTtcbmNvbnN0IFVOSVRfU0VDT05EUyA9IHtcbiAgc2Vjb25kOiBTRUNPTkQsXG4gIHNlY29uZHM6IFNFQ09ORCxcbiAgbWludXRlOiBNSU5VVEUsXG4gIG1pbnV0ZXM6IE1JTlVURSxcbiAgaG91cjogSE9VUixcbiAgaG91cnM6IEhPVVIsXG4gIGRheTogREFZLFxuICBkYXlzOiBEQVksXG4gIHdlZWs6IFdFRUssXG4gIHdlZWtzOiBXRUVLLFxuICBtb250aDogTU9OVEgsXG4gIG1vbnRoczogTU9OVEgsXG4gIHF1YXJ0ZXI6IFFVQVJURVIsXG4gIHF1YXJ0ZXJzOiBRVUFSVEVSLFxuICB5ZWFyOiBZRUFSLFxuICB5ZWFyczogWUVBUlxufTtcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIHtcbiAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIF9jYWNoZTogY2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzID0gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLFxuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcixcbiAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgfSA9IHByb3BzO1xuICBmdW5jdGlvbiBhcHBseVRpbWVab25lKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnM/LnRpbWVab25lKSB7XG4gICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgdGltZVpvbmVcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzPy5bZm9ybWF0TmFtZV07XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIGBGb3JtYXQgXFxgJHtmb3JtYXROYW1lfVxcYCBpcyBub3QgYXZhaWxhYmxlLmAgKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm9ybWF0T3JPcHRpb25zO1xuICAgIH1cbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCB0eXBlRm9ybWF0cywgZm9ybWF0dGVyLCBnZXRGYWxsYmFjaykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfSwgKCkgPT4gW2RhdGVUaW1lKHN0YXJ0KSwgZGF0ZVRpbWUoZW5kKV0uam9pbign4oCJ4oCT4oCJJykpO1xuICB9XG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/Lm51bWJlciwgb3B0aW9ucyA9PiBmb3JtYXR0ZXJzLmdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSksICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICAvLyBPbmx5IHJlYWQgd2hlbiBuZWNlc3NhcnkgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIGBkeW5hbWljSU9gIGVycm9yXG4gICAgLy8gdW5uZWNlc3NhcmlseSAoYG5vd2AgaXMgb25seSBuZWVkZWQgZm9yIGBmb3JtYXQucmVsYXRpdmVUaW1lYClcbiAgICBpZiAocHJvcHMubm93KSB7XG4gICAgICByZXR1cm4gcHJvcHMubm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZSBcXGBub3dcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCB0byBcXGByZWxhdGl2ZVRpbWVcXGAgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQsIHRoZXJlZm9yZSB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCBhcyBhIGZhbGxiYWNrLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93YCApKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUoZGF0ZSwgbm93T3JPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBub3dEYXRlLCB1bml0O1xuICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKG5vd09yT3B0aW9ucykge1xuICAgICAgICBpZiAobm93T3JPcHRpb25zLm5vdyAhPSBudWxsKSB7XG4gICAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgICAgfVxuICAgICAgICB1bml0ID0gbm93T3JPcHRpb25zLnVuaXQ7XG4gICAgICAgIG9wdHMuc3R5bGUgPSBub3dPck9wdGlvbnMuc3R5bGU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZXMgYXJlIHNsaWdodGx5IG91dGRhdGVkXG4gICAgICAgIG9wdHMubnVtYmVyaW5nU3lzdGVtID0gbm93T3JPcHRpb25zLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIH1cbiAgICAgIGlmICghbm93RGF0ZSkge1xuICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgaWYgKCF1bml0KSB7XG4gICAgICAgIHVuaXQgPSByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gYG51bWVyaWM6ICdhdXRvJ2AgY2FuIHRoZW9yZXRpY2FsbHkgcHJvZHVjZSBvdXRwdXQgbGlrZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IGl0IG9ubHkgd29ya3Mgd2l0aCBpbnRlZ2Vycy4gRS5nLiAtMSBkYXkgd2lsbCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgLTEuMSBkYXlzIHdpbGwgcHJvZHVjZSBcIi0xLjEgZGF5c1wiLiBSb3VuZGluZyBiZWZvcmUgZm9ybWF0dGluZyBpc1xuICAgICAgLy8gbm90IGRlc2lyZWQsIGFzIHRoZSBnaXZlbiBkYXRlcyBtaWdodCBjcm9zcyBhIHRocmVzaG9sZCB3ZXJlIHRoZVxuICAgICAgLy8gb3V0cHV0IGlzbid0IGNvcnJlY3QgYW55bW9yZS4gRXhhbXBsZTogMjAyNC0wMS0wOFQyMzowMDowMC4wMDBaIGFuZFxuICAgICAgLy8gMjAyNC0wMS0wOFQwMTowMDowMC4wMDBaIHdvdWxkIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIiwgd2hpY2ggaXMgbm90IHRoZVxuICAgICAgLy8gY2FzZS4gQnkgdXNpbmcgYGFsd2F5c2Agd2UgY2FuIGVuc3VyZSBjb3JyZWN0IG91dHB1dC4gVGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAvLyBpcyB0aGUgZm9ybWF0dGluZyBvZiB0aW1lcyA8MSBzZWNvbmQgYXMgXCJub3dcIi5cbiAgICAgIG9wdHMubnVtZXJpYyA9IHVuaXQgPT09ICdzZWNvbmQnID8gJ2F1dG8nIDogJ2Fsd2F5cyc7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0UmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0cykuZm9ybWF0KHZhbHVlLCB1bml0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBbXTtcbiAgICBjb25zdCByaWNoVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gYGZvcm1hdFRvUGFydHNgIG9ubHkgYWNjZXB0cyBzdHJpbmdzLCB0aGVyZWZvcmUgd2UgaGF2ZSB0byB0ZW1wb3JhcmlseVxuICAgIC8vIHJlcGxhY2UgUmVhY3QgZWxlbWVudHMgd2l0aCBhIHBsYWNlaG9sZGVyIElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcbiAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWUgYWZ0ZXJ3YXJkcy5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIHJpY2hWYWx1ZXMuc2V0KHNlcmlhbGl6ZWRJdGVtLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZFZhbHVlLnB1c2goc2VyaWFsaXplZEl0ZW0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0dGVycy5nZXRMaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgcGFyZW50UGF0aCkge1xuICBPYmplY3QuZW50cmllcyhtZXNzYWdlcykuZm9yRWFjaCgoW2tleSwgbWVzc2FnZU9yTWVzc2FnZXNdKSA9PiB7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBsZXQga2V5TGFiZWwgPSBrZXk7XG4gICAgICBpZiAocGFyZW50UGF0aCkga2V5TGFiZWwgKz0gYCAoYXQgJHtwYXJlbnRQYXRofSlgO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChtZXNzYWdlT3JNZXNzYWdlcyAhPSBudWxsICYmIHR5cGVvZiBtZXNzYWdlT3JNZXNzYWdlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VPck1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBqb2luUGF0aChwYXJlbnRQYXRoLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgb25FcnJvcikge1xuICBjb25zdCBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLklOVkFMSURfS0VZLCBgTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXCIuXCIgYXMgdGhpcyBpcyB1c2VkIHRvIGV4cHJlc3MgbmVzdGluZy4gUGxlYXNlIHJlbW92ZSBpdCBvciByZXBsYWNlIGl0IHdpdGggYW5vdGhlciBjaGFyYWN0ZXIuXG5cbkludmFsaWQgJHtpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA9PT0gMSA/ICdrZXknIDogJ2tleXMnfTogJHtpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJyl9XG5cbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxuXG5pbXBvcnQge3NldH0gZnJvbSBcImxvZGFzaFwiO1xuXG5jb25zdCBpbnB1dCA9IHtcbiAgXCJvbmUub25lXCI6IFwiMS4xXCIsXG4gIFwib25lLnR3b1wiOiBcIjEuMlwiLFxuICBcInR3by5vbmUub25lXCI6IFwiMi4xLjFcIlxufTtcblxuY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMoaW5wdXQpLnJlZHVjZShcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcbiAge31cbik7XG5cbi8vIE91dHB1dDpcbi8vXG4vLyB7XG4vLyAgIFwib25lXCI6IHtcbi8vICAgICBcIm9uZVwiOiBcIjEuMVwiLFxuLy8gICAgIFwidHdvXCI6IFwiMS4yXCJcbi8vICAgfSxcbi8vICAgXCJ0d29cIjoge1xuLy8gICAgIFwib25lXCI6IHtcbi8vICAgICAgIFwib25lXCI6IFwiMi4xLjFcIlxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuYCApKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VzIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKHtcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBtZXNzYWdlcyxcbiAgb25FcnJvcixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBmaW5hbE9uRXJyb3IgPSBvbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xuICBjb25zdCBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgZm9ybWF0czogZm9ybWF0cyB8fCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IHVuZGVmaW5lZCxcbiAgICBvbkVycm9yOiBmaW5hbE9uRXJyb3IsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBmaW5hbEdldE1lc3NhZ2VGYWxsYmFja1xuICB9O1xufVxuXG5leHBvcnQgeyBJbnRsRXJyb3IgYXMgSSwgSW50bEVycm9yQ29kZSBhcyBhLCBjcmVhdGVJbnRsRm9ybWF0dGVycyBhcyBiLCBjcmVhdGVGb3JtYXR0ZXIgYXMgYywgY3JlYXRlQ2FjaGUgYXMgZCwgY3JlYXRlQmFzZVRyYW5zbGF0b3IgYXMgZSwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayBhcyBmLCBkZWZhdWx0T25FcnJvciBhcyBnLCBpbml0aWFsaXplQ29uZmlnIGFzIGksIHJlc29sdmVOYW1lc3BhY2UgYXMgciB9O1xuIl0sIm5hbWVzIjpbIkludGxNZXNzYWdlRm9ybWF0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJtZW1vaXplIiwic3RyYXRlZ2llcyIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsIkludGxFcnJvckNvZGUiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJnbG9iYWxGb3JtYXRzIiwiaW5saW5lRm9ybWF0cyIsInRpbWVab25lIiwibWZEYXRlRGVmYXVsdHMiLCJmb3JtYXRzIiwiZGF0ZSIsIm1mVGltZURlZmF1bHRzIiwidGltZSIsImRhdGVUaW1lRm9ybWF0cyIsImRhdGVUaW1lIiwiYWxsRm9ybWF0cyIsIm51bWJlciIsImZvckVhY2giLCJwcm9wZXJ0eSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImpvaW5QYXRoIiwicGFydHMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJwcm9wcyIsIm5hbWVzcGFjZSIsImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwiY3JlYXRlQ2FjaGUiLCJyZWxhdGl2ZVRpbWUiLCJwbHVyYWxSdWxlcyIsImxpc3QiLCJkaXNwbGF5TmFtZXMiLCJjcmVhdGVNZW1vQ2FjaGUiLCJzdG9yZSIsImNyZWF0ZSIsImdldCIsInNldCIsIm1lbW9GbiIsImZuIiwiY2FjaGUiLCJzdHJhdGVneSIsInZhcmlhZGljIiwibWVtb0NvbnN0cnVjdG9yIiwiQ29uc3RydWN0b3JGbiIsImFyZ3MiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImdldERhdGVUaW1lRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZ2V0TnVtYmVyRm9ybWF0IiwiTnVtYmVyRm9ybWF0IiwiZ2V0UGx1cmFsUnVsZXMiLCJQbHVyYWxSdWxlcyIsImdldFJlbGF0aXZlVGltZUZvcm1hdCIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImdldExpc3RGb3JtYXQiLCJMaXN0Rm9ybWF0IiwiZ2V0RGlzcGxheU5hbWVzIiwiRGlzcGxheU5hbWVzIiwiY3JlYXRlTWVzc2FnZUZvcm1hdHRlciIsImludGxGb3JtYXR0ZXJzIiwiZ2V0TWVzc2FnZUZvcm1hdCIsImZvcm1hdHRlcnMiLCJyZXNvbHZlUGF0aCIsImxvY2FsZSIsIm1lc3NhZ2VzIiwiZnVsbEtleSIsInNwbGl0IiwicGFydCIsIm5leHQiLCJwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJ0cmFuc2Zvcm1lZFZhbHVlcyIsImtleXMiLCJpbmRleCIsInRyYW5zZm9ybWVkIiwiY2h1bmtzIiwicmVzdWx0IiwiZ2V0TWVzc2FnZXNPckVycm9yIiwib25FcnJvciIsInJldHJpZXZlZE1lc3NhZ2VzIiwiaW50bEVycm9yIiwiTUlTU0lOR19NRVNTQUdFIiwiZ2V0UGxhaW5NZXNzYWdlIiwiY2FuZGlkYXRlIiwidGVzdCIsInVuZGVmaW5lZCIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiY29uZmlnIiwibWVzc2FnZXNPckVycm9yIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwiaGFzTWVzc2FnZXNFcnJvciIsImdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5IiwidHJhbnNsYXRlQmFzZUZuIiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJtZXNzYWdlRm9ybWF0IiwicGxhaW5NZXNzYWdlIiwibG9jYWxlcyIsIm9wdGlvbnMiLCJ0aHJvd25FcnJvciIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXQiLCJTdHJpbmciLCJGT1JNQVRUSU5HX0VSUk9SIiwidHJhbnNsYXRlRm4iLCJyaWNoIiwibWFya3VwIiwicmF3IiwiaGFzIiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwibGVuZ3RoIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwiX2NhY2hlIiwiX2Zvcm1hdHRlcnMiLCJnbG9iYWxUaW1lWm9uZSIsImFwcGx5VGltZVpvbmUiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInJlc29sdmVGb3JtYXRPck9wdGlvbnMiLCJ0eXBlRm9ybWF0cyIsImZvcm1hdE9yT3B0aW9ucyIsIm92ZXJyaWRlcyIsImZvcm1hdE5hbWUiLCJNSVNTSU5HX0ZPUk1BVCIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVyIiwiZ2V0RmFsbGJhY2siLCJkYXRlVGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJmb3JtYXRSYW5nZSIsImdldEdsb2JhbE5vdyIsIm5vdyIsIkRhdGUiLCJub3dPck9wdGlvbnMiLCJub3dEYXRlIiwib3B0cyIsInN0eWxlIiwibnVtYmVyaW5nU3lzdGVtIiwiZGF0ZURhdGUiLCJnZXRUaW1lIiwibnVtZXJpYyIsInNlcmlhbGl6ZWRWYWx1ZSIsInJpY2hWYWx1ZXMiLCJNYXAiLCJpdGVtIiwic2VyaWFsaXplZEl0ZW0iLCJwdXNoIiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJzaXplIiwidmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQiLCJpbnZhbGlkS2V5TGFiZWxzIiwicGFyZW50UGF0aCIsIm1lc3NhZ2VPck1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJrZXlMYWJlbCIsInZhbGlkYXRlTWVzc2FnZXMiLCJJTlZBTElEX0tFWSIsImluaXRpYWxpemVDb25maWciLCJyZXN0IiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJJIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImkiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/esm/development/react.js":
/*!*************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/react.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntlProvider: () => (/* binding */ IntlProvider),\n/* harmony export */   useFormatter: () => (/* binding */ useFormatter),\n/* harmony export */   useLocale: () => (/* binding */ useLocale),\n/* harmony export */   useMessages: () => (/* binding */ useMessages),\n/* harmony export */   useNow: () => (/* binding */ useNow),\n/* harmony export */   useTimeZone: () => (/* binding */ useTimeZone),\n/* harmony export */   useTranslations: () => (/* binding */ useTranslations)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./initializeConfig-DPFnvsUO.js */ \"(ssr)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n\n\n\nconst IntlContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nfunction IntlProvider({\n  children,\n  formats,\n  getMessageFallback,\n  locale,\n  messages,\n  now,\n  onError,\n  timeZone\n}) {\n  const prevContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n\n  // The formatter cache is released when the locale changes. For\n  // long-running apps with a persistent `IntlProvider` at the root,\n  // this can reduce the memory footprint (e.g. in React Native).\n  const cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return prevContext?.cache || (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.d)();\n  }, [locale, prevContext?.cache]);\n  const formatters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => prevContext?.formatters || (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.b)(cache), [cache, prevContext?.formatters]);\n\n  // Memoizing this value helps to avoid triggering a re-render of all\n  // context consumers in case the configuration didn't change. However,\n  // if some of the non-primitive values change, a re-render will still\n  // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n  // itself, because the `children` typically change on every render.\n  // There's some burden on the consumer side if it's important to reduce\n  // re-renders, put that's how React works.\n  // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    ...(0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n      locale,\n      // (required by provider)\n      formats: formats === undefined ? prevContext?.formats : formats,\n      getMessageFallback: getMessageFallback || prevContext?.getMessageFallback,\n      messages: messages === undefined ? prevContext?.messages : messages,\n      now: now || prevContext?.now,\n      onError: onError || prevContext?.onError,\n      timeZone: timeZone || prevContext?.timeZone\n    }),\n    formatters,\n    cache\n  }), [cache, formats, formatters, getMessageFallback, locale, messages, now, onError, prevContext, timeZone]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IntlContext.Provider, {\n    value: value,\n    children: children\n  });\n}\nfunction useIntlContext() {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IntlContext);\n  if (!context) {\n    throw new Error('No intl context found. Have you configured the provider? See https://next-intl.dev/docs/usage/configuration#server-client-components');\n  }\n  return context;\n}\nlet hasWarnedForMissingTimezone = false;\nconst isServer = true;\nfunction useTranslationsImpl(allMessagesPrefixed, namespacePrefixed, namespacePrefix) {\n  const {\n    cache,\n    formats: globalFormats,\n    formatters,\n    getMessageFallback,\n    locale,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  const allMessages = allMessagesPrefixed[namespacePrefix];\n  const namespace = (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.r)(namespacePrefixed, namespacePrefix);\n  if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    hasWarnedForMissingTimezone = true;\n    onError(new _initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.I(_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.a.ENVIRONMENT_FALLBACK, `There is no \\`timeZone\\` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl.dev/docs/configuration#time-zone`));\n  }\n  const translate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.e)({\n    cache,\n    formatters,\n    getMessageFallback,\n    messages: allMessages,\n    namespace,\n    onError,\n    formats: globalFormats,\n    locale,\n    timeZone\n  }), [cache, formatters, getMessageFallback, allMessages, namespace, onError, globalFormats, locale, timeZone]);\n  return translate;\n}\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nfunction useTranslations(namespace) {\n  const context = useIntlContext();\n  const messages = context.messages;\n\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  // @ts-expect-error Use the explicit annotation instead\n  return useTranslationsImpl({\n    '!': messages\n  },\n  // @ts-expect-error\n  namespace ? `!.${namespace}` : '!', '!');\n}\nfunction useLocale() {\n  return useIntlContext().locale;\n}\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * @see https://next-intl.dev/docs/usage/dates-times#relative-times-usenow\n */\nfunction useNow(options) {\n  const updateInterval = options?.updateInterval;\n  const {\n    now: globalNow\n  } = useIntlContext();\n  const [now, setNow] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(globalNow || getNow());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!updateInterval) return;\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n  return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n  return useIntlContext().timeZone;\n}\nfunction useMessages() {\n  const context = useIntlContext();\n  if (!context.messages) {\n    throw new Error('No messages found. Have you configured them correctly? See https://next-intl.dev/docs/configuration#messages');\n  }\n  return context.messages;\n}\nfunction useFormatter() {\n  const {\n    formats,\n    formatters,\n    locale,\n    now: globalNow,\n    onError,\n    timeZone\n  } = useIntlContext();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => (0,_initializeConfig_DPFnvsUO_js__WEBPACK_IMPORTED_MODULE_2__.c)({\n    formats,\n    locale,\n    now: globalNow,\n    onError,\n    timeZone,\n    _formatters: formatters\n  }), [formats, formatters, globalNow, locale, onError, timeZone]);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFnRjtBQUNnSjtBQUN4TDtBQUl4QyxNQUFNc0IsV0FBVyxHQUFHLGFBQWF0QixvREFBYSxDQUFDdUIsU0FBUyxDQUFDO0FBRXpELFNBQVNDLFlBQVlBLENBQUM7RUFDcEJDLFFBQVE7RUFDUkMsT0FBTztFQUNQQyxrQkFBa0I7RUFDbEJDLE1BQU07RUFDTkMsUUFBUTtFQUNSQyxHQUFHO0VBQ0hDLE9BQU87RUFDUEM7QUFDRixDQUFDLEVBQUU7RUFDRCxNQUFNQyxXQUFXLEdBQUdoQyxpREFBVSxDQUFDcUIsV0FBVyxDQUFDOztFQUUzQztFQUNBO0VBQ0E7RUFDQSxNQUFNWSxLQUFLLEdBQUdoQyw4Q0FBTyxDQUFDLE1BQU07SUFDMUIsT0FBTytCLFdBQVcsRUFBRUMsS0FBSyxJQUFJNUIsZ0VBQVcsQ0FBQyxDQUFDO0VBQzVDLENBQUMsRUFBRSxDQUFDc0IsTUFBTSxFQUFFSyxXQUFXLEVBQUVDLEtBQUssQ0FBQyxDQUFDO0VBQ2hDLE1BQU1DLFVBQVUsR0FBR2pDLDhDQUFPLENBQUMsTUFBTStCLFdBQVcsRUFBRUUsVUFBVSxJQUFJM0IsZ0VBQW9CLENBQUMwQixLQUFLLENBQUMsRUFBRSxDQUFDQSxLQUFLLEVBQUVELFdBQVcsRUFBRUUsVUFBVSxDQUFDLENBQUM7O0VBRTFIO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQSxNQUFNQyxLQUFLLEdBQUdsQyw4Q0FBTyxDQUFDLE9BQU87SUFDM0IsR0FBR1EsZ0VBQWdCLENBQUM7TUFDbEJrQixNQUFNO01BQ047TUFDQUYsT0FBTyxFQUFFQSxPQUFPLEtBQUtILFNBQVMsR0FBR1UsV0FBVyxFQUFFUCxPQUFPLEdBQUdBLE9BQU87TUFDL0RDLGtCQUFrQixFQUFFQSxrQkFBa0IsSUFBSU0sV0FBVyxFQUFFTixrQkFBa0I7TUFDekVFLFFBQVEsRUFBRUEsUUFBUSxLQUFLTixTQUFTLEdBQUdVLFdBQVcsRUFBRUosUUFBUSxHQUFHQSxRQUFRO01BQ25FQyxHQUFHLEVBQUVBLEdBQUcsSUFBSUcsV0FBVyxFQUFFSCxHQUFHO01BQzVCQyxPQUFPLEVBQUVBLE9BQU8sSUFBSUUsV0FBVyxFQUFFRixPQUFPO01BQ3hDQyxRQUFRLEVBQUVBLFFBQVEsSUFBSUMsV0FBVyxFQUFFRDtJQUNyQyxDQUFDLENBQUM7SUFDRkcsVUFBVTtJQUNWRDtFQUNGLENBQUMsQ0FBQyxFQUFFLENBQUNBLEtBQUssRUFBRVIsT0FBTyxFQUFFUyxVQUFVLEVBQUVSLGtCQUFrQixFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsR0FBRyxFQUFFQyxPQUFPLEVBQUVFLFdBQVcsRUFBRUQsUUFBUSxDQUFDLENBQUM7RUFDNUcsT0FBTyxhQUFhWCxzREFBRyxDQUFDQyxXQUFXLENBQUNlLFFBQVEsRUFBRTtJQUM1Q0QsS0FBSyxFQUFFQSxLQUFLO0lBQ1pYLFFBQVEsRUFBRUE7RUFDWixDQUFDLENBQUM7QUFDSjtBQUVBLFNBQVNhLGNBQWNBLENBQUEsRUFBRztFQUN4QixNQUFNQyxPQUFPLEdBQUd0QyxpREFBVSxDQUFDcUIsV0FBVyxDQUFDO0VBQ3ZDLElBQUksQ0FBQ2lCLE9BQU8sRUFBRTtJQUNaLE1BQU0sSUFBSUMsS0FBSyxDQUFDLHNJQUF1SSxDQUFDO0VBQzFKO0VBQ0EsT0FBT0QsT0FBTztBQUNoQjtBQUVBLElBQUlFLDJCQUEyQixHQUFHLEtBQUs7QUFDdkMsTUFBTUMsUUFBUSxPQUFnQztBQUM5QyxTQUFTQyxtQkFBbUJBLENBQUNDLG1CQUFtQixFQUFFQyxpQkFBaUIsRUFBRUMsZUFBZSxFQUFFO0VBQ3BGLE1BQU07SUFDSlosS0FBSztJQUNMUixPQUFPLEVBQUVxQixhQUFhO0lBQ3RCWixVQUFVO0lBQ1ZSLGtCQUFrQjtJQUNsQkMsTUFBTTtJQUNORyxPQUFPO0lBQ1BDO0VBQ0YsQ0FBQyxHQUFHTSxjQUFjLENBQUMsQ0FBQzs7RUFFcEI7RUFDQTtFQUNBLE1BQU1VLFdBQVcsR0FBR0osbUJBQW1CLENBQUNFLGVBQWUsQ0FBQztFQUN4RCxNQUFNRyxTQUFTLEdBQUdyQyxnRUFBZ0IsQ0FBQ2lDLGlCQUFpQixFQUFFQyxlQUFlLENBQUM7RUFDdEUsSUFBSSxDQUFDZCxRQUFRLElBQUksQ0FBQ1MsMkJBQTJCLElBQUlDLFFBQVEsRUFBRTtJQUN6RDtJQUNBRCwyQkFBMkIsR0FBRyxJQUFJO0lBQ2xDVixPQUFPLENBQUMsSUFBSWpCLDREQUFTLENBQUNFLDREQUFhLENBQUNrQyxvQkFBb0IsRUFBRyxpTUFBaU0sQ0FBQyxDQUFDO0VBQ2hRO0VBQ0EsTUFBTUMsU0FBUyxHQUFHakQsOENBQU8sQ0FBQyxNQUFNZ0IsZ0VBQW9CLENBQUM7SUFDbkRnQixLQUFLO0lBQ0xDLFVBQVU7SUFDVlIsa0JBQWtCO0lBQ2xCRSxRQUFRLEVBQUVtQixXQUFXO0lBQ3JCQyxTQUFTO0lBQ1RsQixPQUFPO0lBQ1BMLE9BQU8sRUFBRXFCLGFBQWE7SUFDdEJuQixNQUFNO0lBQ05JO0VBQ0YsQ0FBQyxDQUFDLEVBQUUsQ0FBQ0UsS0FBSyxFQUFFQyxVQUFVLEVBQUVSLGtCQUFrQixFQUFFcUIsV0FBVyxFQUFFQyxTQUFTLEVBQUVsQixPQUFPLEVBQUVnQixhQUFhLEVBQUVuQixNQUFNLEVBQUVJLFFBQVEsQ0FBQyxDQUFDO0VBQzlHLE9BQU9tQixTQUFTO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxlQUFlQSxDQUFDSCxTQUFTLEVBQUU7RUFDbEMsTUFBTVYsT0FBTyxHQUFHRCxjQUFjLENBQUMsQ0FBQztFQUNoQyxNQUFNVCxRQUFRLEdBQUdVLE9BQU8sQ0FBQ1YsUUFBUTs7RUFFakM7RUFDQTtFQUNBO0VBQ0E7RUFDQSxPQUFPYyxtQkFBbUIsQ0FBQztJQUN6QixHQUFHLEVBQUVkO0VBQ1AsQ0FBQztFQUNEO0VBQ0FvQixTQUFTLEdBQUksS0FBSUEsU0FBVSxFQUFDLEdBQUcsR0FBRyxFQUFFLEdBQUcsQ0FBQztBQUMxQztBQUVBLFNBQVNJLFNBQVNBLENBQUEsRUFBRztFQUNuQixPQUFPZixjQUFjLENBQUMsQ0FBQyxDQUFDVixNQUFNO0FBQ2hDO0FBRUEsU0FBUzBCLE1BQU1BLENBQUEsRUFBRztFQUNoQixPQUFPLElBQUlDLElBQUksQ0FBQyxDQUFDO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVNDLE1BQU1BLENBQUNDLE9BQU8sRUFBRTtFQUN2QixNQUFNQyxjQUFjLEdBQUdELE9BQU8sRUFBRUMsY0FBYztFQUM5QyxNQUFNO0lBQ0o1QixHQUFHLEVBQUU2QjtFQUNQLENBQUMsR0FBR3JCLGNBQWMsQ0FBQyxDQUFDO0VBQ3BCLE1BQU0sQ0FBQ1IsR0FBRyxFQUFFOEIsTUFBTSxDQUFDLEdBQUd6RCwrQ0FBUSxDQUFDd0QsU0FBUyxJQUFJTCxNQUFNLENBQUMsQ0FBQyxDQUFDO0VBQ3JEbEQsZ0RBQVMsQ0FBQyxNQUFNO0lBQ2QsSUFBSSxDQUFDc0QsY0FBYyxFQUFFO0lBQ3JCLE1BQU1HLFVBQVUsR0FBR0MsV0FBVyxDQUFDLE1BQU07TUFDbkNGLE1BQU0sQ0FBQ04sTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDLEVBQUVJLGNBQWMsQ0FBQztJQUNsQixPQUFPLE1BQU07TUFDWEssYUFBYSxDQUFDRixVQUFVLENBQUM7SUFDM0IsQ0FBQztFQUNILENBQUMsRUFBRSxDQUFDRixTQUFTLEVBQUVELGNBQWMsQ0FBQyxDQUFDO0VBQy9CLE9BQU9BLGNBQWMsSUFBSSxJQUFJLElBQUlDLFNBQVMsR0FBR0EsU0FBUyxHQUFHN0IsR0FBRztBQUM5RDtBQUVBLFNBQVNrQyxXQUFXQSxDQUFBLEVBQUc7RUFDckIsT0FBTzFCLGNBQWMsQ0FBQyxDQUFDLENBQUNOLFFBQVE7QUFDbEM7QUFFQSxTQUFTaUMsV0FBV0EsQ0FBQSxFQUFHO0VBQ3JCLE1BQU0xQixPQUFPLEdBQUdELGNBQWMsQ0FBQyxDQUFDO0VBQ2hDLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixRQUFRLEVBQUU7SUFDckIsTUFBTSxJQUFJVyxLQUFLLENBQUMsOEdBQStHLENBQUM7RUFDbEk7RUFDQSxPQUFPRCxPQUFPLENBQUNWLFFBQVE7QUFDekI7QUFFQSxTQUFTcUMsWUFBWUEsQ0FBQSxFQUFHO0VBQ3RCLE1BQU07SUFDSnhDLE9BQU87SUFDUFMsVUFBVTtJQUNWUCxNQUFNO0lBQ05FLEdBQUcsRUFBRTZCLFNBQVM7SUFDZDVCLE9BQU87SUFDUEM7RUFDRixDQUFDLEdBQUdNLGNBQWMsQ0FBQyxDQUFDO0VBQ3BCLE9BQU9wQyw4Q0FBTyxDQUFDLE1BQU1rQixnRUFBZSxDQUFDO0lBQ25DTSxPQUFPO0lBQ1BFLE1BQU07SUFDTkUsR0FBRyxFQUFFNkIsU0FBUztJQUNkNUIsT0FBTztJQUNQQyxRQUFRO0lBQ1JtQyxXQUFXLEVBQUVoQztFQUNmLENBQUMsQ0FBQyxFQUFFLENBQUNULE9BQU8sRUFBRVMsVUFBVSxFQUFFd0IsU0FBUyxFQUFFL0IsTUFBTSxFQUFFRyxPQUFPLEVBQUVDLFFBQVEsQ0FBQyxDQUFDO0FBQ2xFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVudGJhYmUtbmV4dGpzLW1pZ3JhdGlvbi8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2VzbS9kZXZlbG9wbWVudC9yZWFjdC5qcz9mNmQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBkIGFzIGNyZWF0ZUNhY2hlLCBiIGFzIGNyZWF0ZUludGxGb3JtYXR0ZXJzLCBpIGFzIGluaXRpYWxpemVDb25maWcsIHIgYXMgcmVzb2x2ZU5hbWVzcGFjZSwgSSBhcyBJbnRsRXJyb3IsIGEgYXMgSW50bEVycm9yQ29kZSwgZSBhcyBjcmVhdGVCYXNlVHJhbnNsYXRvciwgYyBhcyBjcmVhdGVGb3JtYXR0ZXIgfSBmcm9tICcuL2luaXRpYWxpemVDb25maWctRFBGbnZzVU8uanMnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5cblxuY29uc3QgSW50bENvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiBJbnRsUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBsb2NhbGUsXG4gIG1lc3NhZ2VzLFxuICBub3csXG4gIG9uRXJyb3IsXG4gIHRpbWVab25lXG59KSB7XG4gIGNvbnN0IHByZXZDb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG5cbiAgLy8gVGhlIGZvcm1hdHRlciBjYWNoZSBpcyByZWxlYXNlZCB3aGVuIHRoZSBsb2NhbGUgY2hhbmdlcy4gRm9yXG4gIC8vIGxvbmctcnVubmluZyBhcHBzIHdpdGggYSBwZXJzaXN0ZW50IGBJbnRsUHJvdmlkZXJgIGF0IHRoZSByb290LFxuICAvLyB0aGlzIGNhbiByZWR1Y2UgdGhlIG1lbW9yeSBmb290cHJpbnQgKGUuZy4gaW4gUmVhY3QgTmF0aXZlKS5cbiAgY29uc3QgY2FjaGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gcHJldkNvbnRleHQ/LmNhY2hlIHx8IGNyZWF0ZUNhY2hlKCk7XG4gIH0sIFtsb2NhbGUsIHByZXZDb250ZXh0Py5jYWNoZV0pO1xuICBjb25zdCBmb3JtYXR0ZXJzID0gdXNlTWVtbygoKSA9PiBwcmV2Q29udGV4dD8uZm9ybWF0dGVycyB8fCBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSksIFtjYWNoZSwgcHJldkNvbnRleHQ/LmZvcm1hdHRlcnNdKTtcblxuICAvLyBNZW1vaXppbmcgdGhpcyB2YWx1ZSBoZWxwcyB0byBhdm9pZCB0cmlnZ2VyaW5nIGEgcmUtcmVuZGVyIG9mIGFsbFxuICAvLyBjb250ZXh0IGNvbnN1bWVycyBpbiBjYXNlIHRoZSBjb25maWd1cmF0aW9uIGRpZG4ndCBjaGFuZ2UuIEhvd2V2ZXIsXG4gIC8vIGlmIHNvbWUgb2YgdGhlIG5vbi1wcmltaXRpdmUgdmFsdWVzIGNoYW5nZSwgYSByZS1yZW5kZXIgd2lsbCBzdGlsbFxuICAvLyBiZSB0cmlnZ2VyZWQuIE5vdGUgdGhhdCB0aGVyZSdzIG5vIG5lZWQgdG8gcHV0IGBtZW1vYCBvbiBgSW50bFByb3ZpZGVyYFxuICAvLyBpdHNlbGYsIGJlY2F1c2UgdGhlIGBjaGlsZHJlbmAgdHlwaWNhbGx5IGNoYW5nZSBvbiBldmVyeSByZW5kZXIuXG4gIC8vIFRoZXJlJ3Mgc29tZSBidXJkZW4gb24gdGhlIGNvbnN1bWVyIHNpZGUgaWYgaXQncyBpbXBvcnRhbnQgdG8gcmVkdWNlXG4gIC8vIHJlLXJlbmRlcnMsIHB1dCB0aGF0J3MgaG93IFJlYWN0IHdvcmtzLlxuICAvLyBTZWU6IGh0dHBzOi8vYmxvZy5pc3F1YXJlZHNvZnR3YXJlLmNvbS8yMDIwLzA1L2Jsb2dnZWQtYW5zd2Vycy1hLW1vc3RseS1jb21wbGV0ZS1ndWlkZS10by1yZWFjdC1yZW5kZXJpbmctYmVoYXZpb3IvI2NvbnRleHQtdXBkYXRlcy1hbmQtcmVuZGVyLW9wdGltaXphdGlvbnNcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgLi4uaW5pdGlhbGl6ZUNvbmZpZyh7XG4gICAgICBsb2NhbGUsXG4gICAgICAvLyAocmVxdWlyZWQgYnkgcHJvdmlkZXIpXG4gICAgICBmb3JtYXRzOiBmb3JtYXRzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8uZm9ybWF0cyA6IGZvcm1hdHMsXG4gICAgICBnZXRNZXNzYWdlRmFsbGJhY2s6IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBwcmV2Q29udGV4dD8uZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzID09PSB1bmRlZmluZWQgPyBwcmV2Q29udGV4dD8ubWVzc2FnZXMgOiBtZXNzYWdlcyxcbiAgICAgIG5vdzogbm93IHx8IHByZXZDb250ZXh0Py5ub3csXG4gICAgICBvbkVycm9yOiBvbkVycm9yIHx8IHByZXZDb250ZXh0Py5vbkVycm9yLFxuICAgICAgdGltZVpvbmU6IHRpbWVab25lIHx8IHByZXZDb250ZXh0Py50aW1lWm9uZVxuICAgIH0pLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgY2FjaGVcbiAgfSksIFtjYWNoZSwgZm9ybWF0cywgZm9ybWF0dGVycywgZ2V0TWVzc2FnZUZhbGxiYWNrLCBsb2NhbGUsIG1lc3NhZ2VzLCBub3csIG9uRXJyb3IsIHByZXZDb250ZXh0LCB0aW1lWm9uZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChJbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZUludGxDb250ZXh0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChJbnRsQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gaW50bCBjb250ZXh0IGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZSBwcm92aWRlcj8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL2NvbmZpZ3VyYXRpb24jc2VydmVyLWNsaWVudC1jb21wb25lbnRzJyApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5sZXQgaGFzV2FybmVkRm9yTWlzc2luZ1RpbWV6b25lID0gZmFsc2U7XG5jb25zdCBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zSW1wbChhbGxNZXNzYWdlc1ByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXhlZCwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIGNvbnN0IHtcbiAgICBjYWNoZSxcbiAgICBmb3JtYXRzOiBnbG9iYWxGb3JtYXRzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuXG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBob29rIGludm9jYXRpb24uXG4gIGNvbnN0IGFsbE1lc3NhZ2VzID0gYWxsTWVzc2FnZXNQcmVmaXhlZFtuYW1lc3BhY2VQcmVmaXhdO1xuICBjb25zdCBuYW1lc3BhY2UgPSByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZVByZWZpeGVkLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtY29tcGlsZXIvcmVhY3QtY29tcGlsZXJcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLkVOVklST05NRU5UX0ZBTExCQUNLLCBgVGhlcmUgaXMgbm8gXFxgdGltZVpvbmVcXGAgY29uZmlndXJlZCwgdGhpcyBjYW4gbGVhZCB0byBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0OiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gIH1cbiAgY29uc3QgdHJhbnNsYXRlID0gdXNlTWVtbygoKSA9PiBjcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgY2FjaGUsXG4gICAgZm9ybWF0dGVycyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXM6IGFsbE1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIHRpbWVab25lXG4gIH0pLCBbY2FjaGUsIGZvcm1hdHRlcnMsIGdldE1lc3NhZ2VGYWxsYmFjaywgYWxsTWVzc2FnZXMsIG5hbWVzcGFjZSwgb25FcnJvciwgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgbWVzc2FnZXMgPSBjb250ZXh0Lm1lc3NhZ2VzO1xuXG4gIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgYWN0dWFsIGhvb2sgc28gdGhlIHR5cGUgaW5mZXJlbmNlIGZvciB0aGUgb3B0aW9uYWxcbiAgLy8gbmFtZXNwYWNlIHdvcmtzIGNvcnJlY3RseS4gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTUyOTU3NS8zNDMwNDVcbiAgLy8gVGhlIHByZWZpeCAoXCIhXCIpIGlzIGFyYml0cmFyeS5cbiAgLy8gQHRzLWV4cGVjdC1lcnJvciBVc2UgdGhlIGV4cGxpY2l0IGFubm90YXRpb24gaW5zdGVhZFxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IGAhLiR7bmFtZXNwYWNlfWAgOiAnIScsICchJyk7XG59XG5cbmZ1bmN0aW9uIHVzZUxvY2FsZSgpIHtcbiAgcmV0dXJuIHVzZUludGxDb250ZXh0KCkubG9jYWxlO1xufVxuXG5mdW5jdGlvbiBnZXROb3coKSB7XG4gIHJldHVybiBuZXcgRGF0ZSgpO1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93XG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucz8udXBkYXRlSW50ZXJ2YWw7XG4gIGNvbnN0IHtcbiAgICBub3c6IGdsb2JhbE5vd1xuICB9ID0gdXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IHVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gdXBkYXRlSW50ZXJ2YWwgPT0gbnVsbCAmJiBnbG9iYWxOb3cgPyBnbG9iYWxOb3cgOiBub3c7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVab25lKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS50aW1lWm9uZTtcbn1cblxuZnVuY3Rpb24gdXNlTWVzc2FnZXMoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VJbnRsQ29udGV4dCgpO1xuICBpZiAoIWNvbnRleHQubWVzc2FnZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1lc3NhZ2VzIGZvdW5kLiBIYXZlIHlvdSBjb25maWd1cmVkIHRoZW0gY29ycmVjdGx5PyBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvY29uZmlndXJhdGlvbiNtZXNzYWdlcycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dC5tZXNzYWdlcztcbn1cblxuZnVuY3Rpb24gdXNlRm9ybWF0dGVyKCkge1xuICBjb25zdCB7XG4gICAgZm9ybWF0cyxcbiAgICBmb3JtYXR0ZXJzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yLFxuICAgIHRpbWVab25lXG4gIH0gPSB1c2VJbnRsQ29udGV4dCgpO1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmUsXG4gICAgX2Zvcm1hdHRlcnM6IGZvcm1hdHRlcnNcbiAgfSksIFtmb3JtYXRzLCBmb3JtYXR0ZXJzLCBnbG9iYWxOb3csIGxvY2FsZSwgb25FcnJvciwgdGltZVpvbmVdKTtcbn1cblxuZXhwb3J0IHsgSW50bFByb3ZpZGVyLCB1c2VGb3JtYXR0ZXIsIHVzZUxvY2FsZSwgdXNlTWVzc2FnZXMsIHVzZU5vdywgdXNlVGltZVpvbmUsIHVzZVRyYW5zbGF0aW9ucyB9O1xuIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiZCIsImNyZWF0ZUNhY2hlIiwiYiIsImNyZWF0ZUludGxGb3JtYXR0ZXJzIiwiaSIsImluaXRpYWxpemVDb25maWciLCJyIiwicmVzb2x2ZU5hbWVzcGFjZSIsIkkiLCJJbnRsRXJyb3IiLCJhIiwiSW50bEVycm9yQ29kZSIsImUiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImMiLCJjcmVhdGVGb3JtYXR0ZXIiLCJqc3giLCJJbnRsQ29udGV4dCIsInVuZGVmaW5lZCIsIkludGxQcm92aWRlciIsImNoaWxkcmVuIiwiZm9ybWF0cyIsImdldE1lc3NhZ2VGYWxsYmFjayIsImxvY2FsZSIsIm1lc3NhZ2VzIiwibm93Iiwib25FcnJvciIsInRpbWVab25lIiwicHJldkNvbnRleHQiLCJjYWNoZSIsImZvcm1hdHRlcnMiLCJ2YWx1ZSIsIlByb3ZpZGVyIiwidXNlSW50bENvbnRleHQiLCJjb250ZXh0IiwiRXJyb3IiLCJoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUiLCJpc1NlcnZlciIsInVzZVRyYW5zbGF0aW9uc0ltcGwiLCJhbGxNZXNzYWdlc1ByZWZpeGVkIiwibmFtZXNwYWNlUHJlZml4ZWQiLCJuYW1lc3BhY2VQcmVmaXgiLCJnbG9iYWxGb3JtYXRzIiwiYWxsTWVzc2FnZXMiLCJuYW1lc3BhY2UiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInRyYW5zbGF0ZSIsInVzZVRyYW5zbGF0aW9ucyIsInVzZUxvY2FsZSIsImdldE5vdyIsIkRhdGUiLCJ1c2VOb3ciLCJvcHRpb25zIiwidXBkYXRlSW50ZXJ2YWwiLCJnbG9iYWxOb3ciLCJzZXROb3ciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidXNlVGltZVpvbmUiLCJ1c2VNZXNzYWdlcyIsInVzZUZvcm1hdHRlciIsIl9mb3JtYXR0ZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/esm/development/react.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IntlError),\n/* harmony export */   a: () => (/* binding */ IntlErrorCode),\n/* harmony export */   b: () => (/* binding */ createIntlFormatters),\n/* harmony export */   c: () => (/* binding */ createFormatter),\n/* harmony export */   d: () => (/* binding */ createCache),\n/* harmony export */   e: () => (/* binding */ createBaseTranslator),\n/* harmony export */   f: () => (/* binding */ defaultGetMessageFallback),\n/* harmony export */   g: () => (/* binding */ defaultOnError),\n/* harmony export */   i: () => (/* binding */ initializeConfig),\n/* harmony export */   r: () => (/* binding */ resolveNamespace)\n/* harmony export */ });\n/* harmony import */ var intl_messageformat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/src/core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @formatjs/fast-memoize */ \"(rsc)/./node_modules/@formatjs/fast-memoize/lib/index.js\");\n\n\n\nclass IntlError extends Error {\n  constructor(code, originalMessage) {\n    let message = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\nvar IntlErrorCode = /*#__PURE__*/function (IntlErrorCode) {\n  IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n  IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n  IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n  IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n  IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n  IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n  IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n  return IntlErrorCode;\n}(IntlErrorCode || {});\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nfunction convertFormatsToIntlMessageFormat(globalFormats, inlineFormats, timeZone) {\n  const mfDateDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.date;\n  const mfTimeDefaults = intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat.formats.time;\n  const dateTimeFormats = {\n    ...globalFormats?.dateTime,\n    ...inlineFormats?.dateTime\n  };\n  const allFormats = {\n    date: {\n      ...mfDateDefaults,\n      ...dateTimeFormats\n    },\n    time: {\n      ...mfTimeDefaults,\n      ...dateTimeFormats\n    },\n    number: {\n      ...globalFormats?.number,\n      ...inlineFormats?.number\n    }\n    // (list is not supported in ICU messages)\n  };\n\n  if (timeZone) {\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    ['date', 'time'].forEach(property => {\n      const formats = allFormats[property];\n      for (const [key, value] of Object.entries(formats)) {\n        formats[key] = {\n          timeZone,\n          ...value\n        };\n      }\n    });\n  }\n  return allFormats;\n}\nfunction joinPath(...parts) {\n  return parts.filter(Boolean).join('.');\n}\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nfunction defaultGetMessageFallback(props) {\n  return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n  console.error(error);\n}\nfunction createCache() {\n  return {\n    dateTime: {},\n    number: {},\n    message: {},\n    relativeTime: {},\n    pluralRules: {},\n    list: {},\n    displayNames: {}\n  };\n}\nfunction createMemoCache(store) {\n  return {\n    create() {\n      return {\n        get(key) {\n          return store[key];\n        },\n        set(key, value) {\n          store[key] = value;\n        }\n      };\n    }\n  };\n}\nfunction memoFn(fn, cache) {\n  return (0,_formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.memoize)(fn, {\n    cache: createMemoCache(cache),\n    strategy: _formatjs_fast_memoize__WEBPACK_IMPORTED_MODULE_1__.strategies.variadic\n  });\n}\nfunction memoConstructor(ConstructorFn, cache) {\n  return memoFn((...args) => new ConstructorFn(...args), cache);\n}\nfunction createIntlFormatters(cache) {\n  const getDateTimeFormat = memoConstructor(Intl.DateTimeFormat, cache.dateTime);\n  const getNumberFormat = memoConstructor(Intl.NumberFormat, cache.number);\n  const getPluralRules = memoConstructor(Intl.PluralRules, cache.pluralRules);\n  const getRelativeTimeFormat = memoConstructor(Intl.RelativeTimeFormat, cache.relativeTime);\n  const getListFormat = memoConstructor(Intl.ListFormat, cache.list);\n  const getDisplayNames = memoConstructor(Intl.DisplayNames, cache.displayNames);\n  return {\n    getDateTimeFormat,\n    getNumberFormat,\n    getPluralRules,\n    getRelativeTimeFormat,\n    getListFormat,\n    getDisplayNames\n  };\n}\n\n// Placed here for improved tree shaking. Somehow when this is placed in\n// `formatters.tsx`, then it can't be shaken off from `next-intl`.\nfunction createMessageFormatter(cache, intlFormatters) {\n  const getMessageFormat = memoFn((...args) => new intl_messageformat__WEBPACK_IMPORTED_MODULE_2__.IntlMessageFormat(args[0], args[1], args[2], {\n    formatters: intlFormatters,\n    ...args[3]\n  }), cache.message);\n  return getMessageFormat;\n}\nfunction resolvePath(locale, messages, key, namespace) {\n  const fullKey = joinPath(namespace, key);\n  if (!messages) {\n    throw new Error(`No messages available at \\`${namespace}\\`.`);\n  }\n  let message = messages;\n  key.split('.').forEach(part => {\n    const next = message[part];\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (part == null || next == null) {\n      throw new Error(`Could not resolve \\`${fullKey}\\` in messages for locale \\`${locale}\\`.`);\n    }\n    message = next;\n  });\n  return message;\n}\nfunction prepareTranslationValues(values) {\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues = {};\n  Object.keys(values).forEach(key => {\n    let index = 0;\n    const value = values[key];\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = chunks => {\n        const result = value(chunks);\n        return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(result) ? /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(result, {\n          key: key + index++\n        }) : result;\n      };\n    } else {\n      transformed = value;\n    }\n    transformedValues[key] = transformed;\n  });\n  return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace, onError = defaultOnError) {\n  try {\n    if (!messages) {\n      throw new Error(`No messages were configured.`);\n    }\n    const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!retrievedMessages) {\n      throw new Error(`No messages for namespace \\`${namespace}\\` found.`);\n    }\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);\n    onError(intlError);\n    return intlError;\n  }\n}\nfunction getPlainMessage(candidate, values) {\n  // To improve runtime performance, only compile message if:\n  return (\n    // 1. Values are provided\n    values ||\n    // 2. There are escaped braces (e.g. \"'{name'}\")\n    /'[{}]/.test(candidate) ||\n    // 3. There are missing arguments or tags (dev-only error handling)\n    /<|{/.test(candidate) ? undefined // Compile\n    : candidate // Don't compile\n  );\n}\n\nfunction createBaseTranslator(config) {\n  const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n  return createBaseTranslatorImpl({\n    ...config,\n    messagesOrError\n  });\n}\nfunction createBaseTranslatorImpl({\n  cache,\n  formats: globalFormats,\n  formatters,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}) {\n  const hasMessagesError = messagesOrError instanceof IntlError;\n  function getFallbackFromErrorAndNotify(key, code, message) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({\n      error,\n      key,\n      namespace\n    });\n  }\n  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    let message;\n    try {\n      message = resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n    if (typeof message === 'object') {\n      let code, errorMessage;\n      if (Array.isArray(message)) {\n        code = IntlErrorCode.INVALID_MESSAGE;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an array, but only strings are supported. See https://next-intl.dev/docs/usage/messages#arrays-of-messages`;\n        }\n      } else {\n        code = IntlErrorCode.INSUFFICIENT_PATH;\n        {\n          errorMessage = `Message at \\`${joinPath(namespace, key)}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl.dev/docs/usage/messages#structuring-messages`;\n        }\n      }\n      return getFallbackFromErrorAndNotify(key, code, errorMessage);\n    }\n    let messageFormat;\n\n    // Hot path that avoids creating an `IntlMessageFormat` instance\n    const plainMessage = getPlainMessage(message, values);\n    if (plainMessage) return plainMessage;\n\n    // Lazy init the message formatter for better tree\n    // shaking in case message formatting is not used.\n    if (!formatters.getMessageFormat) {\n      formatters.getMessageFormat = createMessageFormatter(cache, formatters);\n    }\n    try {\n      messageFormat = formatters.getMessageFormat(message, locale, convertFormatsToIntlMessageFormat(globalFormats, formats, timeZone), {\n        formatters: {\n          ...formatters,\n          getDateTimeFormat(locales, options) {\n            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n            return formatters.getDateTimeFormat(locales, {\n              timeZone,\n              ...options\n            });\n          }\n        }\n      });\n    } catch (error) {\n      const thrownError = error;\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, thrownError.message + ('originalMessage' in thrownError ? ` (${thrownError.originalMessage})` : ''));\n    }\n    try {\n      const formattedMessage = messageFormat.format(\n      // @ts-expect-error `intl-messageformat` expects a different format\n      // for rich text elements since a recent minor update. This\n      // needs to be evaluated in detail, possibly also in regards\n      // to be able to format to parts.\n      values ? prepareTranslationValues(values) : values);\n      if (formattedMessage == null) {\n        throw new Error(`Unable to format \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'}`);\n      }\n\n      // Limit the function signature to return strings or React elements\n      return /*#__PURE__*/ /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(formattedMessage) ||\n      // Arrays of React elements\n      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);\n    }\n  }\n  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n  key, /** Key value pairs for values to interpolate into the message. */\n  values, /** Provide custom formats for numbers, dates and times. */\n  formats) {\n    const result = translateBaseFn(key, values, formats);\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, `The message \\`${key}\\` in ${namespace ? `namespace \\`${namespace}\\`` : 'messages'} didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`);\n    }\n    return result;\n  }\n  translateFn.rich = translateBaseFn;\n\n  // Augment `translateBaseFn` to return plain strings\n  translateFn.markup = (key, values, formats) => {\n    const result = translateBaseFn(key,\n    // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n    // of `RichTranslationValues` but TypeScript isn't smart enough here.\n    values, formats);\n    if (typeof result !== 'string') {\n      const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n      onError(error);\n      return getMessageFallback({\n        error,\n        key,\n        namespace\n      });\n    }\n    return result;\n  };\n  translateFn.raw = key => {\n    if (hasMessagesError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n    try {\n      return resolvePath(locale, messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);\n    }\n  };\n  translateFn.has = key => {\n    if (hasMessagesError) {\n      return false;\n    }\n    try {\n      resolvePath(locale, messagesOrError, key, namespace);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  return translateFn;\n}\n\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nfunction resolveNamespace(namespace, namespacePrefix) {\n  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n  const absValue = Math.abs(seconds);\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(props) {\n  const {\n    _cache: cache = createCache(),\n    _formatters: formatters = createIntlFormatters(cache),\n    formats,\n    locale,\n    onError = defaultOnError,\n    timeZone: globalTimeZone\n  } = props;\n  function applyTimeZone(options) {\n    if (!options?.timeZone) {\n      if (globalTimeZone) {\n        options = {\n          ...options,\n          timeZone: globalTimeZone\n        };\n      } else {\n        onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl.dev/docs/configuration#time-zone`));\n      }\n    }\n    return options;\n  }\n  function resolveFormatOrOptions(typeFormats, formatOrOptions, overrides) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n      if (!options) {\n        const error = new IntlError(IntlErrorCode.MISSING_FORMAT, `Format \\`${formatName}\\` is not available.`);\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n    if (overrides) {\n      options = {\n        ...options,\n        ...overrides\n      };\n    }\n    return options;\n  }\n  function getFormattedValue(formatOrOptions, overrides, typeFormats, formatter, getFallback) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions, overrides);\n    } catch {\n      return getFallback();\n    }\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return getFallback();\n    }\n  }\n  function dateTime(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).format(value);\n    }, () => String(value));\n  }\n  function dateTimeRange(start, end, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.dateTime, options => {\n      options = applyTimeZone(options);\n      return formatters.getDateTimeFormat(locale, options).formatRange(start, end);\n    }, () => [dateTime(start), dateTime(end)].join(' – '));\n  }\n  function number(value, formatOrOptions, overrides) {\n    return getFormattedValue(formatOrOptions, overrides, formats?.number, options => formatters.getNumberFormat(locale, options).format(value), () => String(value));\n  }\n  function getGlobalNow() {\n    // Only read when necessary to avoid triggering a `dynamicIO` error\n    // unnecessarily (`now` is only needed for `format.relativeTime`)\n    if (props.now) {\n      return props.now;\n    } else {\n      onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, `The \\`now\\` parameter wasn't provided to \\`relativeTime\\` and there is no global default configured, therefore the current time will be used as a fallback. See https://next-intl.dev/docs/usage/dates-times#relative-times-usenow`));\n      return new Date();\n    }\n  }\n  function relativeTime(date, nowOrOptions) {\n    try {\n      let nowDate, unit;\n      const opts = {};\n      if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n        nowDate = new Date(nowOrOptions);\n      } else if (nowOrOptions) {\n        if (nowOrOptions.now != null) {\n          nowDate = new Date(nowOrOptions.now);\n        } else {\n          nowDate = getGlobalNow();\n        }\n        unit = nowOrOptions.unit;\n        opts.style = nowOrOptions.style;\n        // @ts-expect-error -- Types are slightly outdated\n        opts.numberingSystem = nowOrOptions.numberingSystem;\n      }\n      if (!nowDate) {\n        nowDate = getGlobalNow();\n      }\n      const dateDate = new Date(date);\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      if (!unit) {\n        unit = resolveRelativeTimeUnit(seconds);\n      }\n\n      // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n      // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n      // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n      // not desired, as the given dates might cross a threshold were the\n      // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n      // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n      // case. By using `always` we can ensure correct output. The only exception\n      // is the formatting of times <1 second as \"now\".\n      opts.numeric = unit === 'second' ? 'auto' : 'always';\n      const value = calculateRelativeTimeValue(seconds, unit);\n      return formatters.getRelativeTimeFormat(locale, opts).format(value, unit);\n    } catch (error) {\n      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));\n      return String(date);\n    }\n  }\n  function list(value, formatOrOptions, overrides) {\n    const serializedValue = [];\n    const richValues = new Map();\n\n    // `formatToParts` only accepts strings, therefore we have to temporarily\n    // replace React elements with a placeholder ID that can be used to retrieve\n    // the original value afterwards.\n    let index = 0;\n    for (const item of value) {\n      let serializedItem;\n      if (typeof item === 'object') {\n        serializedItem = String(index);\n        richValues.set(serializedItem, item);\n      } else {\n        serializedItem = String(item);\n      }\n      serializedValue.push(serializedItem);\n      index++;\n    }\n    return getFormattedValue(formatOrOptions, overrides, formats?.list,\n    // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n    options => {\n      const result = formatters.getListFormat(locale, options).formatToParts(serializedValue).map(part => part.type === 'literal' ? part.value : richValues.get(part.value) || part.value);\n      if (richValues.size > 0) {\n        return result;\n      } else {\n        return result.join('');\n      }\n    }, () => String(value));\n  }\n  return {\n    dateTime,\n    number,\n    relativeTime,\n    list,\n    dateTimeRange\n  };\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n  Object.entries(messages).forEach(([key, messageOrMessages]) => {\n    if (key.includes('.')) {\n      let keyLabel = key;\n      if (parentPath) keyLabel += ` (at ${parentPath})`;\n      invalidKeyLabels.push(keyLabel);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (messageOrMessages != null && typeof messageOrMessages === 'object') {\n      validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n    }\n  });\n}\nfunction validateMessages(messages, onError) {\n  const invalidKeyLabels = [];\n  validateMessagesSegment(messages, invalidKeyLabels);\n  if (invalidKeyLabels.length > 0) {\n    onError(new IntlError(IntlErrorCode.INVALID_KEY, `Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid ${invalidKeyLabels.length === 1 ? 'key' : 'keys'}: ${invalidKeyLabels.join(', ')}\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n`));\n  }\n}\n\n/**\n * Enhances the incoming props with defaults.\n */\nfunction initializeConfig({\n  formats,\n  getMessageFallback,\n  messages,\n  onError,\n  ...rest\n}) {\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n  {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n  return {\n    ...rest,\n    formats: formats || undefined,\n    messages: messages || undefined,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9lc20vZGV2ZWxvcG1lbnQvaW5pdGlhbGl6ZUNvbmZpZy1EUEZudnNVTy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVEO0FBQ0Y7QUFDUTtBQUU3RCxNQUFNSyxTQUFTLFNBQVNDLEtBQUssQ0FBQztFQUM1QkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxlQUFlLEVBQUU7SUFDakMsSUFBSUMsT0FBTyxHQUFHRixJQUFJO0lBQ2xCLElBQUlDLGVBQWUsRUFBRTtNQUNuQkMsT0FBTyxJQUFJLElBQUksR0FBR0QsZUFBZTtJQUNuQztJQUNBLEtBQUssQ0FBQ0MsT0FBTyxDQUFDO0lBQ2QsSUFBSSxDQUFDRixJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSUMsZUFBZSxFQUFFO01BQ25CLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxlQUFlO0lBQ3hDO0VBQ0Y7QUFDRjtBQUVBLElBQUlFLGFBQWEsR0FBRyxhQUFhLFVBQVVBLGFBQWEsRUFBRTtFQUN4REEsYUFBYSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsaUJBQWlCO0VBQ3BEQSxhQUFhLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxnQkFBZ0I7RUFDbERBLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLHNCQUFzQjtFQUM5REEsYUFBYSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsbUJBQW1CO0VBQ3hEQSxhQUFhLENBQUMsaUJBQWlCLENBQUMsR0FBRyxpQkFBaUI7RUFDcERBLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBRyxhQUFhO0VBQzVDQSxhQUFhLENBQUMsa0JBQWtCLENBQUMsR0FBRyxrQkFBa0I7RUFDdEQsT0FBT0EsYUFBYTtBQUN0QixDQUFDLENBQUNBLGFBQWEsSUFBSSxDQUFDLENBQUMsQ0FBQzs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxpQ0FBaUNBLENBQUNDLGFBQWEsRUFBRUMsYUFBYSxF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YmFiZS1uZXh0anMtbWlncmF0aW9uLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZXNtL2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctRFBGbnZzVU8uanM/YmI3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbnRsTWVzc2FnZUZvcm1hdCB9IGZyb20gJ2ludGwtbWVzc2FnZWZvcm1hdCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVtb2l6ZSwgc3RyYXRlZ2llcyB9IGZyb20gJ0Bmb3JtYXRqcy9mYXN0LW1lbW9pemUnO1xuXG5jbGFzcyBJbnRsRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNvZGUsIG9yaWdpbmFsTWVzc2FnZSkge1xuICAgIGxldCBtZXNzYWdlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2U7XG4gICAgfVxuICB9XG59XG5cbnZhciBJbnRsRXJyb3JDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChJbnRsRXJyb3JDb2RlKSB7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX01FU1NBR0VcIl0gPSBcIk1JU1NJTkdfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19GT1JNQVRcIl0gPSBcIk1JU1NJTkdfRk9STUFUXCI7XG4gIEludGxFcnJvckNvZGVbXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiXSA9IFwiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9QQVRIXCJdID0gXCJJTlNVRkZJQ0lFTlRfUEFUSFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVNTQUdFXCJdID0gXCJJTlZBTElEX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfS0VZXCJdID0gXCJJTlZBTElEX0tFWVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRk9STUFUVElOR19FUlJPUlwiXSA9IFwiRk9STUFUVElOR19FUlJPUlwiO1xuICByZXR1cm4gSW50bEVycm9yQ29kZTtcbn0oSW50bEVycm9yQ29kZSB8fCB7fSk7XG5cbi8qKlxuICogYGludGwtbWVzc2FnZWZvcm1hdGAgdXNlcyBzZXBhcmF0ZSBrZXlzIGZvciBgZGF0ZWAgYW5kIGB0aW1lYCwgYnV0IHRoZXJlJ3NcbiAqIG9ubHkgb25lIG5hdGl2ZSBBUEk6IGBJbnRsLkRhdGVUaW1lRm9ybWF0YC4gQWRkaXRpb25hbGx5IHlvdSBtaWdodCB3YW50IHRvXG4gKiBpbmNsdWRlIGJvdGggYSB0aW1lIGFuZCBhIGRhdGUgaW4gYSB2YWx1ZSwgdGhlcmVmb3JlIHRoZSBzZXBhcmF0aW9uIGRvZXNuJ3RcbiAqIHNlZW0gc28gdXNlZnVsLiBXZSBvZmZlciBhIHNpbmdsZSBgZGF0ZVRpbWVgIG5hbWVzcGFjZSBpbnN0ZWFkLCBidXQgd2UgaGF2ZVxuICogdG8gY29udmVydCB0aGUgZm9ybWF0IGJlZm9yZSBgaW50bC1tZXNzYWdlZm9ybWF0YCBjYW4gYmUgdXNlZC5cbiAqL1xuZnVuY3Rpb24gY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGlubGluZUZvcm1hdHMsIHRpbWVab25lKSB7XG4gIGNvbnN0IG1mRGF0ZURlZmF1bHRzID0gSW50bE1lc3NhZ2VGb3JtYXQuZm9ybWF0cy5kYXRlO1xuICBjb25zdCBtZlRpbWVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0LmZvcm1hdHMudGltZTtcbiAgY29uc3QgZGF0ZVRpbWVGb3JtYXRzID0ge1xuICAgIC4uLmdsb2JhbEZvcm1hdHM/LmRhdGVUaW1lLFxuICAgIC4uLmlubGluZUZvcm1hdHM/LmRhdGVUaW1lXG4gIH07XG4gIGNvbnN0IGFsbEZvcm1hdHMgPSB7XG4gICAgZGF0ZToge1xuICAgICAgLi4ubWZEYXRlRGVmYXVsdHMsXG4gICAgICAuLi5kYXRlVGltZUZvcm1hdHNcbiAgICB9LFxuICAgIHRpbWU6IHtcbiAgICAgIC4uLm1mVGltZURlZmF1bHRzLFxuICAgICAgLi4uZGF0ZVRpbWVGb3JtYXRzXG4gICAgfSxcbiAgICBudW1iZXI6IHtcbiAgICAgIC4uLmdsb2JhbEZvcm1hdHM/Lm51bWJlcixcbiAgICAgIC4uLmlubGluZUZvcm1hdHM/Lm51bWJlclxuICAgIH1cbiAgICAvLyAobGlzdCBpcyBub3Qgc3VwcG9ydGVkIGluIElDVSBtZXNzYWdlcylcbiAgfTtcbiAgaWYgKHRpbWVab25lKSB7XG4gICAgLy8gVGhlIG9ubHkgd2F5IHRvIHNldCBhIHRpbWUgem9uZSB3aXRoIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGlzIHRvIG1lcmdlIGl0IGludG8gdGhlIGZvcm1hdHNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvYmxvYi84MjU2YzUyNzE1MDVjZjI2MDZlNDhlM2M5N2VjZGQxNmVkZTRmMWI1L3BhY2thZ2VzL2ludGwvc3JjL21lc3NhZ2UudHMjTDE1XG4gICAgWydkYXRlJywgJ3RpbWUnXS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICAgIGNvbnN0IGZvcm1hdHMgPSBhbGxGb3JtYXRzW3Byb3BlcnR5XTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZvcm1hdHMpKSB7XG4gICAgICAgIGZvcm1hdHNba2V5XSA9IHtcbiAgICAgICAgICB0aW1lWm9uZSxcbiAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBhbGxGb3JtYXRzO1xufVxuXG5mdW5jdGlvbiBqb2luUGF0aCguLi5wYXJ0cykge1xuICByZXR1cm4gcGFydHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBkZWZhdWx0cyB0aGF0IGFyZSB1c2VkIGZvciBhbGwgZW50cnkgcG9pbnRzIGludG8gdGhlIGNvcmUuXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gam9pblBhdGgocHJvcHMubmFtZXNwYWNlLCBwcm9wcy5rZXkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICByZXR1cm4ge1xuICAgIGRhdGVUaW1lOiB7fSxcbiAgICBudW1iZXI6IHt9LFxuICAgIG1lc3NhZ2U6IHt9LFxuICAgIHJlbGF0aXZlVGltZToge30sXG4gICAgcGx1cmFsUnVsZXM6IHt9LFxuICAgIGxpc3Q6IHt9LFxuICAgIGRpc3BsYXlOYW1lczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lbW9DYWNoZShzdG9yZSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBzdG9yZVtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbWVtb0ZuKGZuLCBjYWNoZSkge1xuICByZXR1cm4gbWVtb2l6ZShmbiwge1xuICAgIGNhY2hlOiBjcmVhdGVNZW1vQ2FjaGUoY2FjaGUpLFxuICAgIHN0cmF0ZWd5OiBzdHJhdGVnaWVzLnZhcmlhZGljXG4gIH0pO1xufVxuZnVuY3Rpb24gbWVtb0NvbnN0cnVjdG9yKENvbnN0cnVjdG9yRm4sIGNhY2hlKSB7XG4gIHJldHVybiBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBDb25zdHJ1Y3RvckZuKC4uLmFyZ3MpLCBjYWNoZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVJbnRsRm9ybWF0dGVycyhjYWNoZSkge1xuICBjb25zdCBnZXREYXRlVGltZUZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLkRhdGVUaW1lRm9ybWF0LCBjYWNoZS5kYXRlVGltZSk7XG4gIGNvbnN0IGdldE51bWJlckZvcm1hdCA9IG1lbW9Db25zdHJ1Y3RvcihJbnRsLk51bWJlckZvcm1hdCwgY2FjaGUubnVtYmVyKTtcbiAgY29uc3QgZ2V0UGx1cmFsUnVsZXMgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5QbHVyYWxSdWxlcywgY2FjaGUucGx1cmFsUnVsZXMpO1xuICBjb25zdCBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQsIGNhY2hlLnJlbGF0aXZlVGltZSk7XG4gIGNvbnN0IGdldExpc3RGb3JtYXQgPSBtZW1vQ29uc3RydWN0b3IoSW50bC5MaXN0Rm9ybWF0LCBjYWNoZS5saXN0KTtcbiAgY29uc3QgZ2V0RGlzcGxheU5hbWVzID0gbWVtb0NvbnN0cnVjdG9yKEludGwuRGlzcGxheU5hbWVzLCBjYWNoZS5kaXNwbGF5TmFtZXMpO1xuICByZXR1cm4ge1xuICAgIGdldERhdGVUaW1lRm9ybWF0LFxuICAgIGdldE51bWJlckZvcm1hdCxcbiAgICBnZXRQbHVyYWxSdWxlcyxcbiAgICBnZXRSZWxhdGl2ZVRpbWVGb3JtYXQsXG4gICAgZ2V0TGlzdEZvcm1hdCxcbiAgICBnZXREaXNwbGF5TmFtZXNcbiAgfTtcbn1cblxuLy8gUGxhY2VkIGhlcmUgZm9yIGltcHJvdmVkIHRyZWUgc2hha2luZy4gU29tZWhvdyB3aGVuIHRoaXMgaXMgcGxhY2VkIGluXG4vLyBgZm9ybWF0dGVycy50c3hgLCB0aGVuIGl0IGNhbid0IGJlIHNoYWtlbiBvZmYgZnJvbSBgbmV4dC1pbnRsYC5cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VGb3JtYXR0ZXIoY2FjaGUsIGludGxGb3JtYXR0ZXJzKSB7XG4gIGNvbnN0IGdldE1lc3NhZ2VGb3JtYXQgPSBtZW1vRm4oKC4uLmFyZ3MpID0+IG5ldyBJbnRsTWVzc2FnZUZvcm1hdChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCB7XG4gICAgZm9ybWF0dGVyczogaW50bEZvcm1hdHRlcnMsXG4gICAgLi4uYXJnc1szXVxuICB9KSwgY2FjaGUubWVzc2FnZSk7XG4gIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KTtcbiAgaWYgKCFtZXNzYWdlcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IFxcYCR7bmFtZXNwYWNlfVxcYC5gICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgaWYgKHBhcnQgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgXFxgJHtmdWxsS2V5fVxcYCBpbiBtZXNzYWdlcyBmb3IgbG9jYWxlIFxcYCR7bG9jYWxlfVxcYC5gICk7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSBuZXh0O1xuICB9KTtcbiAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXModmFsdWVzKSB7XG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMTQ2N1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gY2h1bmtzID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoY2h1bmtzKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9pc1ZhbGlkRWxlbWVudChyZXN1bHQpID8gLyojX19QVVJFX18qL2Nsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlLCBvbkVycm9yID0gZGVmYXVsdE9uRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZC5gICk7XG4gICAgfVxuICAgIGNvbnN0IHJldHJpZXZlZE1lc3NhZ2VzID0gbmFtZXNwYWNlID8gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSA6IG1lc3NhZ2VzO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbiAgICBpZiAoIXJldHJpZXZlZE1lc3NhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1lc3NhZ2VzIGZvciBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgIGZvdW5kLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldHJpZXZlZE1lc3NhZ2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnN0IGludGxFcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoaW50bEVycm9yKTtcbiAgICByZXR1cm4gaW50bEVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFpbk1lc3NhZ2UoY2FuZGlkYXRlLCB2YWx1ZXMpIHtcbiAgLy8gVG8gaW1wcm92ZSBydW50aW1lIHBlcmZvcm1hbmNlLCBvbmx5IGNvbXBpbGUgbWVzc2FnZSBpZjpcbiAgcmV0dXJuIChcbiAgICAvLyAxLiBWYWx1ZXMgYXJlIHByb3ZpZGVkXG4gICAgdmFsdWVzIHx8XG4gICAgLy8gMi4gVGhlcmUgYXJlIGVzY2FwZWQgYnJhY2VzIChlLmcuIFwiJ3tuYW1lJ31cIilcbiAgICAvJ1t7fV0vLnRlc3QoY2FuZGlkYXRlKSB8fFxuICAgIC8vIDMuIFRoZXJlIGFyZSBtaXNzaW5nIGFyZ3VtZW50cyBvciB0YWdzIChkZXYtb25seSBlcnJvciBoYW5kbGluZylcbiAgICAvPHx7Ly50ZXN0KGNhbmRpZGF0ZSkgPyB1bmRlZmluZWQgLy8gQ29tcGlsZVxuICAgIDogY2FuZGlkYXRlIC8vIERvbid0IGNvbXBpbGVcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUJhc2VUcmFuc2xhdG9yKGNvbmZpZykge1xuICBjb25zdCBtZXNzYWdlc09yRXJyb3IgPSBnZXRNZXNzYWdlc09yRXJyb3IoY29uZmlnLmxvY2FsZSwgY29uZmlnLm1lc3NhZ2VzLCBjb25maWcubmFtZXNwYWNlLCBjb25maWcub25FcnJvcik7XG4gIHJldHVybiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLmNvbmZpZyxcbiAgICBtZXNzYWdlc09yRXJyb3JcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvckltcGwoe1xuICBjYWNoZSxcbiAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgZm9ybWF0dGVycyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayxcbiAgbG9jYWxlLFxuICBtZXNzYWdlc09yRXJyb3IsXG4gIG5hbWVzcGFjZSxcbiAgb25FcnJvcixcbiAgdGltZVpvbmVcbn0pIHtcbiAgY29uc3QgaGFzTWVzc2FnZXNFcnJvciA9IG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIEludGxFcnJvcjtcbiAgZnVuY3Rpb24gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKGNvZGUsIG1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgZXJyb3IsXG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlID0gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLk1JU1NJTkdfTUVTU0FHRSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGxldCBjb2RlLCBlcnJvck1lc3NhZ2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShtZXNzYWdlKSkge1xuICAgICAgICBjb2RlID0gSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0U7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgTWVzc2FnZSBhdCBcXGAke2pvaW5QYXRoKG5hbWVzcGFjZSwga2V5KX1cXGAgcmVzb2x2ZWQgdG8gYW4gYXJyYXksIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL21lc3NhZ2VzI2FycmF5cy1vZi1tZXNzYWdlc2A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgPSBJbnRsRXJyb3JDb2RlLklOU1VGRklDSUVOVF9QQVRIO1xuICAgICAgICB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gYE1lc3NhZ2UgYXQgXFxgJHtqb2luUGF0aChuYW1lc3BhY2UsIGtleSl9XFxgIHJlc29sdmVkIHRvIGFuIG9iamVjdCwgYnV0IG9ubHkgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLiBVc2UgYSBcXGAuXFxgIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLmRldi9kb2NzL3VzYWdlL21lc3NhZ2VzI3N0cnVjdHVyaW5nLW1lc3NhZ2VzYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gICAgbGV0IG1lc3NhZ2VGb3JtYXQ7XG5cbiAgICAvLyBIb3QgcGF0aCB0aGF0IGF2b2lkcyBjcmVhdGluZyBhbiBgSW50bE1lc3NhZ2VGb3JtYXRgIGluc3RhbmNlXG4gICAgY29uc3QgcGxhaW5NZXNzYWdlID0gZ2V0UGxhaW5NZXNzYWdlKG1lc3NhZ2UsIHZhbHVlcyk7XG4gICAgaWYgKHBsYWluTWVzc2FnZSkgcmV0dXJuIHBsYWluTWVzc2FnZTtcblxuICAgIC8vIExhenkgaW5pdCB0aGUgbWVzc2FnZSBmb3JtYXR0ZXIgZm9yIGJldHRlciB0cmVlXG4gICAgLy8gc2hha2luZyBpbiBjYXNlIG1lc3NhZ2UgZm9ybWF0dGluZyBpcyBub3QgdXNlZC5cbiAgICBpZiAoIWZvcm1hdHRlcnMuZ2V0TWVzc2FnZUZvcm1hdCkge1xuICAgICAgZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0ID0gY3JlYXRlTWVzc2FnZUZvcm1hdHRlcihjYWNoZSwgZm9ybWF0dGVycyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBtZXNzYWdlRm9ybWF0ID0gZm9ybWF0dGVycy5nZXRNZXNzYWdlRm9ybWF0KG1lc3NhZ2UsIGxvY2FsZSwgY29udmVydEZvcm1hdHNUb0ludGxNZXNzYWdlRm9ybWF0KGdsb2JhbEZvcm1hdHMsIGZvcm1hdHMsIHRpbWVab25lKSwge1xuICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgLi4uZm9ybWF0dGVycyxcbiAgICAgICAgICBnZXREYXRlVGltZUZvcm1hdChsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvaXNzdWVzLzQyNzlcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIHtcbiAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IHRocm93bkVycm9yID0gZXJyb3I7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBJbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgdGhyb3duRXJyb3IubWVzc2FnZSArICgnb3JpZ2luYWxNZXNzYWdlJyBpbiB0aHJvd25FcnJvciA/IGAgKCR7dGhyb3duRXJyb3Iub3JpZ2luYWxNZXNzYWdlfSlgIDogJycpICk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gbWVzc2FnZUZvcm1hdC5mb3JtYXQoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIGV4cGVjdHMgYSBkaWZmZXJlbnQgZm9ybWF0XG4gICAgICAvLyBmb3IgcmljaCB0ZXh0IGVsZW1lbnRzIHNpbmNlIGEgcmVjZW50IG1pbm9yIHVwZGF0ZS4gVGhpc1xuICAgICAgLy8gbmVlZHMgdG8gYmUgZXZhbHVhdGVkIGluIGRldGFpbCwgcG9zc2libHkgYWxzbyBpbiByZWdhcmRzXG4gICAgICAvLyB0byBiZSBhYmxlIHRvIGZvcm1hdCB0byBwYXJ0cy5cbiAgICAgIHZhbHVlcyA/IHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIDogdmFsdWVzKTtcbiAgICAgIGlmIChmb3JtYXR0ZWRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZm9ybWF0IFxcYCR7a2V5fVxcYCBpbiAke25hbWVzcGFjZSA/IGBuYW1lc3BhY2UgXFxgJHtuYW1lc3BhY2V9XFxgYCA6ICdtZXNzYWdlcyd9YCApO1xuICAgICAgfVxuXG4gICAgICAvLyBMaW1pdCB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHRvIHJldHVybiBzdHJpbmdzIG9yIFJlYWN0IGVsZW1lbnRzXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2lzVmFsaWRFbGVtZW50KGZvcm1hdHRlZE1lc3NhZ2UpIHx8XG4gICAgICAvLyBBcnJheXMgb2YgUmVhY3QgZWxlbWVudHNcbiAgICAgIEFycmF5LmlzQXJyYXkoZm9ybWF0dGVkTWVzc2FnZSkgfHwgdHlwZW9mIGZvcm1hdHRlZE1lc3NhZ2UgPT09ICdzdHJpbmcnID8gZm9ybWF0dGVkTWVzc2FnZSA6IFN0cmluZyhmb3JtYXR0ZWRNZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNsYXRlRm4oLyoqIFVzZSBhIGRvdCB0byBpbmRpY2F0ZSBhIGxldmVsIG9mIG5lc3RpbmcgKGUuZy4gYG5hbWVzcGFjZS5uZXN0ZWRMYWJlbGApLiAqL1xuICBrZXksIC8qKiBLZXkgdmFsdWUgcGFpcnMgZm9yIHZhbHVlcyB0byBpbnRlcnBvbGF0ZSBpbnRvIHRoZSBtZXNzYWdlLiAqL1xuICB2YWx1ZXMsIC8qKiBQcm92aWRlIGN1c3RvbSBmb3JtYXRzIGZvciBudW1iZXJzLCBkYXRlcyBhbmQgdGltZXMuICovXG4gIGZvcm1hdHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LCB2YWx1ZXMsIGZvcm1hdHMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5JTlZBTElEX01FU1NBR0UsIGBUaGUgbWVzc2FnZSBcXGAke2tleX1cXGAgaW4gJHtuYW1lc3BhY2UgPyBgbmFtZXNwYWNlIFxcYCR7bmFtZXNwYWNlfVxcYGAgOiAnbWVzc2FnZXMnfSBkaWRuJ3QgcmVzb2x2ZSB0byBhIHN0cmluZy4gSWYgeW91IHdhbnQgdG8gZm9ybWF0IHJpY2ggdGV4dCwgdXNlIFxcYHQucmljaFxcYCBpbnN0ZWFkLmAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0cmFuc2xhdGVGbi5yaWNoID0gdHJhbnNsYXRlQmFzZUZuO1xuXG4gIC8vIEF1Z21lbnQgYHRyYW5zbGF0ZUJhc2VGbmAgdG8gcmV0dXJuIHBsYWluIHN0cmluZ3NcbiAgdHJhbnNsYXRlRm4ubWFya3VwID0gKGtleSwgdmFsdWVzLCBmb3JtYXRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdHJhbnNsYXRlQmFzZUZuKGtleSxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0tIGBNYXJrdXBUcmFuc2xhdGlvblZhbHVlc2AgaXMgcHJhY3RpY2FsbHkgYSBzdWIgdHlwZVxuICAgIC8vIG9mIGBSaWNoVHJhbnNsYXRpb25WYWx1ZXNgIGJ1dCBUeXBlU2NyaXB0IGlzbid0IHNtYXJ0IGVub3VnaCBoZXJlLlxuICAgIHZhbHVlcywgZm9ybWF0cyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiKTtcbiAgICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHRyYW5zbGF0ZUZuLnJhdyA9IGtleSA9PiB7XG4gICAgaWYgKGhhc01lc3NhZ2VzRXJyb3IpIHtcbiAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQgdGhpcyBkdXJpbmcgcmVuZGVyXG4gICAgICByZXR1cm4gZ2V0TWVzc2FnZUZhbGxiYWNrKHtcbiAgICAgICAgZXJyb3I6IG1lc3NhZ2VzT3JFcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IG1lc3NhZ2VzT3JFcnJvcjtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlc29sdmVQYXRoKGxvY2FsZSwgbWVzc2FnZXMsIGtleSwgbmFtZXNwYWNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcbiAgdHJhbnNsYXRlRm4uaGFzID0ga2V5ID0+IHtcbiAgICBpZiAoaGFzTWVzc2FnZXNFcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlc09yRXJyb3IsIGtleSwgbmFtZXNwYWNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYW5zbGF0ZUZuO1xufVxuXG4vKipcbiAqIEZvciB0aGUgc3RyaWN0bHkgdHlwZWQgbWVzc2FnZXMgdG8gd29yayB3ZSBoYXZlIHRvIHdyYXAgdGhlIG5hbWVzcGFjZSBpbnRvXG4gKiBhIG1hbmRhdG9yeSBwcmVmaXguIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNzE1Mjk1NzUvMzQzMDQ1XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpIHtcbiAgcmV0dXJuIG5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlUHJlZml4ID8gdW5kZWZpbmVkIDogbmFtZXNwYWNlLnNsaWNlKChuYW1lc3BhY2VQcmVmaXggKyAnLicpLmxlbmd0aCk7XG59XG5cbmNvbnN0IFNFQ09ORCA9IDE7XG5jb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcbmNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcbmNvbnN0IERBWSA9IEhPVVIgKiAyNDtcbmNvbnN0IFdFRUsgPSBEQVkgKiA3O1xuY29uc3QgTU9OVEggPSBEQVkgKiAoMzY1IC8gMTIpOyAvLyBBcHByb3hpbWF0aW9uXG5jb25zdCBRVUFSVEVSID0gTU9OVEggKiAzO1xuY29uc3QgWUVBUiA9IERBWSAqIDM2NTtcbmNvbnN0IFVOSVRfU0VDT05EUyA9IHtcbiAgc2Vjb25kOiBTRUNPTkQsXG4gIHNlY29uZHM6IFNFQ09ORCxcbiAgbWludXRlOiBNSU5VVEUsXG4gIG1pbnV0ZXM6IE1JTlVURSxcbiAgaG91cjogSE9VUixcbiAgaG91cnM6IEhPVVIsXG4gIGRheTogREFZLFxuICBkYXlzOiBEQVksXG4gIHdlZWs6IFdFRUssXG4gIHdlZWtzOiBXRUVLLFxuICBtb250aDogTU9OVEgsXG4gIG1vbnRoczogTU9OVEgsXG4gIHF1YXJ0ZXI6IFFVQVJURVIsXG4gIHF1YXJ0ZXJzOiBRVUFSVEVSLFxuICB5ZWFyOiBZRUFSLFxuICB5ZWFyczogWUVBUlxufTtcbmZ1bmN0aW9uIHJlc29sdmVSZWxhdGl2ZVRpbWVVbml0KHNlY29uZHMpIHtcbiAgY29uc3QgYWJzVmFsdWUgPSBNYXRoLmFicyhzZWNvbmRzKTtcbiAgaWYgKGFic1ZhbHVlIDwgTUlOVVRFKSB7XG4gICAgcmV0dXJuICdzZWNvbmQnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgSE9VUikge1xuICAgIHJldHVybiAnbWludXRlJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IERBWSkge1xuICAgIHJldHVybiAnaG91cic7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBXRUVLKSB7XG4gICAgcmV0dXJuICdkYXknO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgTU9OVEgpIHtcbiAgICByZXR1cm4gJ3dlZWsnO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgWUVBUikge1xuICAgIHJldHVybiAnbW9udGgnO1xuICB9XG4gIHJldHVybiAneWVhcic7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZShzZWNvbmRzLCB1bml0KSB7XG4gIC8vIFdlIGhhdmUgdG8gcm91bmQgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIGFzIGBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdGBcbiAgLy8gd2lsbCBpbmNsdWRlIGZyYWN0aW9ucyBsaWtlICcyLjEgaG91cnMgYWdvJy5cbiAgcmV0dXJuIE1hdGgucm91bmQoc2Vjb25kcyAvIFVOSVRfU0VDT05EU1t1bml0XSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIF9jYWNoZTogY2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuICAgIF9mb3JtYXR0ZXJzOiBmb3JtYXR0ZXJzID0gY3JlYXRlSW50bEZvcm1hdHRlcnMoY2FjaGUpLFxuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG9uRXJyb3IgPSBkZWZhdWx0T25FcnJvcixcbiAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgfSA9IHByb3BzO1xuICBmdW5jdGlvbiBhcHBseVRpbWVab25lKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnM/LnRpbWVab25lKSB7XG4gICAgICBpZiAoZ2xvYmFsVGltZVpvbmUpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIHRpbWVab25lOiBnbG9iYWxUaW1lWm9uZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIGBUaGUgXFxgdGltZVpvbmVcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCBhbmQgdGhlcmUgaXMgbm8gZ2xvYmFsIGRlZmF1bHQgY29uZmlndXJlZC4gQ29uc2lkZXIgYWRkaW5nIGEgZ2xvYmFsIGRlZmF1bHQgdG8gYXZvaWQgbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBMZWFybiBtb3JlOiBodHRwczovL25leHQtaW50bC5kZXYvZG9jcy9jb25maWd1cmF0aW9uI3RpbWUtem9uZWAgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXRPck9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBmb3JtYXROYW1lID0gZm9ybWF0T3JPcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHR5cGVGb3JtYXRzPy5bZm9ybWF0TmFtZV07XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuTUlTU0lOR19GT1JNQVQsIGBGb3JtYXQgXFxgJHtmb3JtYXROYW1lfVxcYCBpcyBub3QgYXZhaWxhYmxlLmAgKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm9ybWF0T3JPcHRpb25zO1xuICAgIH1cbiAgICBpZiAob3ZlcnJpZGVzKSB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5vdmVycmlkZXNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCB0eXBlRm9ybWF0cywgZm9ybWF0dGVyLCBnZXRGYWxsYmFjaykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICBvcHRpb25zID0gcmVzb2x2ZUZvcm1hdE9yT3B0aW9ucyh0eXBlRm9ybWF0cywgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGdldEZhbGxiYWNrKCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUodmFsdWUsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0KHZhbHVlKTtcbiAgICB9LCAoKSA9PiBTdHJpbmcodmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBkYXRlVGltZVJhbmdlKHN0YXJ0LCBlbmQsIGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLmdldERhdGVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfSwgKCkgPT4gW2RhdGVUaW1lKHN0YXJ0KSwgZGF0ZVRpbWUoZW5kKV0uam9pbign4oCJ4oCT4oCJJykpO1xuICB9XG4gIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMsIGZvcm1hdHM/Lm51bWJlciwgb3B0aW9ucyA9PiBmb3JtYXR0ZXJzLmdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSksICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICAvLyBPbmx5IHJlYWQgd2hlbiBuZWNlc3NhcnkgdG8gYXZvaWQgdHJpZ2dlcmluZyBhIGBkeW5hbWljSU9gIGVycm9yXG4gICAgLy8gdW5uZWNlc3NhcmlseSAoYG5vd2AgaXMgb25seSBuZWVkZWQgZm9yIGBmb3JtYXQucmVsYXRpdmVUaW1lYClcbiAgICBpZiAocHJvcHMubm93KSB7XG4gICAgICByZXR1cm4gcHJvcHMubm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBJbnRsRXJyb3IoSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgYFRoZSBcXGBub3dcXGAgcGFyYW1ldGVyIHdhc24ndCBwcm92aWRlZCB0byBcXGByZWxhdGl2ZVRpbWVcXGAgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQsIHRoZXJlZm9yZSB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCBhcyBhIGZhbGxiYWNrLiBTZWUgaHR0cHM6Ly9uZXh0LWludGwuZGV2L2RvY3MvdXNhZ2UvZGF0ZXMtdGltZXMjcmVsYXRpdmUtdGltZXMtdXNlbm93YCApKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUoZGF0ZSwgbm93T3JPcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBub3dEYXRlLCB1bml0O1xuICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgaWYgKG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgdHlwZW9mIG5vd09yT3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKG5vd09yT3B0aW9ucykge1xuICAgICAgICBpZiAobm93T3JPcHRpb25zLm5vdyAhPSBudWxsKSB7XG4gICAgICAgICAgbm93RGF0ZSA9IG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vd0RhdGUgPSBnZXRHbG9iYWxOb3coKTtcbiAgICAgICAgfVxuICAgICAgICB1bml0ID0gbm93T3JPcHRpb25zLnVuaXQ7XG4gICAgICAgIG9wdHMuc3R5bGUgPSBub3dPck9wdGlvbnMuc3R5bGU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gVHlwZXMgYXJlIHNsaWdodGx5IG91dGRhdGVkXG4gICAgICAgIG9wdHMubnVtYmVyaW5nU3lzdGVtID0gbm93T3JPcHRpb25zLm51bWJlcmluZ1N5c3RlbTtcbiAgICAgIH1cbiAgICAgIGlmICghbm93RGF0ZSkge1xuICAgICAgICBub3dEYXRlID0gZ2V0R2xvYmFsTm93KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRlRGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgaWYgKCF1bml0KSB7XG4gICAgICAgIHVuaXQgPSByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKTtcbiAgICAgIH1cblxuICAgICAgLy8gYG51bWVyaWM6ICdhdXRvJ2AgY2FuIHRoZW9yZXRpY2FsbHkgcHJvZHVjZSBvdXRwdXQgbGlrZSBcInllc3RlcmRheVwiLFxuICAgICAgLy8gYnV0IGl0IG9ubHkgd29ya3Mgd2l0aCBpbnRlZ2Vycy4gRS5nLiAtMSBkYXkgd2lsbCBwcm9kdWNlIFwieWVzdGVyZGF5XCIsXG4gICAgICAvLyBidXQgLTEuMSBkYXlzIHdpbGwgcHJvZHVjZSBcIi0xLjEgZGF5c1wiLiBSb3VuZGluZyBiZWZvcmUgZm9ybWF0dGluZyBpc1xuICAgICAgLy8gbm90IGRlc2lyZWQsIGFzIHRoZSBnaXZlbiBkYXRlcyBtaWdodCBjcm9zcyBhIHRocmVzaG9sZCB3ZXJlIHRoZVxuICAgICAgLy8gb3V0cHV0IGlzbid0IGNvcnJlY3QgYW55bW9yZS4gRXhhbXBsZTogMjAyNC0wMS0wOFQyMzowMDowMC4wMDBaIGFuZFxuICAgICAgLy8gMjAyNC0wMS0wOFQwMTowMDowMC4wMDBaIHdvdWxkIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIiwgd2hpY2ggaXMgbm90IHRoZVxuICAgICAgLy8gY2FzZS4gQnkgdXNpbmcgYGFsd2F5c2Agd2UgY2FuIGVuc3VyZSBjb3JyZWN0IG91dHB1dC4gVGhlIG9ubHkgZXhjZXB0aW9uXG4gICAgICAvLyBpcyB0aGUgZm9ybWF0dGluZyBvZiB0aW1lcyA8MSBzZWNvbmQgYXMgXCJub3dcIi5cbiAgICAgIG9wdHMubnVtZXJpYyA9IHVuaXQgPT09ICdzZWNvbmQnID8gJ2F1dG8nIDogJ2Fsd2F5cyc7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlKHNlY29uZHMsIHVuaXQpO1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZ2V0UmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwgb3B0cykuZm9ybWF0KHZhbHVlLCB1bml0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSkpO1xuICAgICAgcmV0dXJuIFN0cmluZyhkYXRlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbGlzdCh2YWx1ZSwgZm9ybWF0T3JPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBbXTtcbiAgICBjb25zdCByaWNoVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gYGZvcm1hdFRvUGFydHNgIG9ubHkgYWNjZXB0cyBzdHJpbmdzLCB0aGVyZWZvcmUgd2UgaGF2ZSB0byB0ZW1wb3JhcmlseVxuICAgIC8vIHJlcGxhY2UgUmVhY3QgZWxlbWVudHMgd2l0aCBhIHBsYWNlaG9sZGVyIElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcbiAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWUgYWZ0ZXJ3YXJkcy5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIHJpY2hWYWx1ZXMuc2V0KHNlcmlhbGl6ZWRJdGVtLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZFZhbHVlLnB1c2goc2VyaWFsaXplZEl0ZW0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgb3ZlcnJpZGVzLCBmb3JtYXRzPy5saXN0LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYHJpY2hWYWx1ZXMuc2l6ZWAgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHJldHVybiB0eXBlLCBidXQgVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0aGUgbWVhbmluZyBvZiB0aGlzIGNvcnJlY3RseVxuICAgIG9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm9ybWF0dGVycy5nZXRMaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzU2VnbWVudChtZXNzYWdlcywgaW52YWxpZEtleUxhYmVscywgcGFyZW50UGF0aCkge1xuICBPYmplY3QuZW50cmllcyhtZXNzYWdlcykuZm9yRWFjaCgoW2tleSwgbWVzc2FnZU9yTWVzc2FnZXNdKSA9PiB7XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLicpKSB7XG4gICAgICBsZXQga2V5TGFiZWwgPSBrZXk7XG4gICAgICBpZiAocGFyZW50UGF0aCkga2V5TGFiZWwgKz0gYCAoYXQgJHtwYXJlbnRQYXRofSlgO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIGlmIChtZXNzYWdlT3JNZXNzYWdlcyAhPSBudWxsICYmIHR5cGVvZiBtZXNzYWdlT3JNZXNzYWdlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VPck1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBqb2luUGF0aChwYXJlbnRQYXRoLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlcyhtZXNzYWdlcywgb25FcnJvcikge1xuICBjb25zdCBpbnZhbGlkS2V5TGFiZWxzID0gW107XG4gIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzKTtcbiAgaWYgKGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID4gMCkge1xuICAgIG9uRXJyb3IobmV3IEludGxFcnJvcihJbnRsRXJyb3JDb2RlLklOVkFMSURfS0VZLCBgTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXCIuXCIgYXMgdGhpcyBpcyB1c2VkIHRvIGV4cHJlc3MgbmVzdGluZy4gUGxlYXNlIHJlbW92ZSBpdCBvciByZXBsYWNlIGl0IHdpdGggYW5vdGhlciBjaGFyYWN0ZXIuXG5cbkludmFsaWQgJHtpbnZhbGlkS2V5TGFiZWxzLmxlbmd0aCA9PT0gMSA/ICdrZXknIDogJ2tleXMnfTogJHtpbnZhbGlkS2V5TGFiZWxzLmpvaW4oJywgJyl9XG5cbklmIHlvdSdyZSBtaWdyYXRpbmcgZnJvbSBhIGZsYXQgc3RydWN0dXJlLCB5b3UgY2FuIGNvbnZlcnQgeW91ciBtZXNzYWdlcyBhcyBmb2xsb3dzOlxuXG5pbXBvcnQge3NldH0gZnJvbSBcImxvZGFzaFwiO1xuXG5jb25zdCBpbnB1dCA9IHtcbiAgXCJvbmUub25lXCI6IFwiMS4xXCIsXG4gIFwib25lLnR3b1wiOiBcIjEuMlwiLFxuICBcInR3by5vbmUub25lXCI6IFwiMi4xLjFcIlxufTtcblxuY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMoaW5wdXQpLnJlZHVjZShcbiAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBzZXQoYWNjLCBrZXksIHZhbHVlKSxcbiAge31cbik7XG5cbi8vIE91dHB1dDpcbi8vXG4vLyB7XG4vLyAgIFwib25lXCI6IHtcbi8vICAgICBcIm9uZVwiOiBcIjEuMVwiLFxuLy8gICAgIFwidHdvXCI6IFwiMS4yXCJcbi8vICAgfSxcbi8vICAgXCJ0d29cIjoge1xuLy8gICAgIFwib25lXCI6IHtcbi8vICAgICAgIFwib25lXCI6IFwiMi4xLjFcIlxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuYCApKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuaGFuY2VzIHRoZSBpbmNvbWluZyBwcm9wcyB3aXRoIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQ29uZmlnKHtcbiAgZm9ybWF0cyxcbiAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICBtZXNzYWdlcyxcbiAgb25FcnJvcixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBmaW5hbE9uRXJyb3IgPSBvbkVycm9yIHx8IGRlZmF1bHRPbkVycm9yO1xuICBjb25zdCBmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayA9IGdldE1lc3NhZ2VGYWxsYmFjayB8fCBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuICB7XG4gICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBmaW5hbE9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLnJlc3QsXG4gICAgZm9ybWF0czogZm9ybWF0cyB8fCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZXM6IG1lc3NhZ2VzIHx8IHVuZGVmaW5lZCxcbiAgICBvbkVycm9yOiBmaW5hbE9uRXJyb3IsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBmaW5hbEdldE1lc3NhZ2VGYWxsYmFja1xuICB9O1xufVxuXG5leHBvcnQgeyBJbnRsRXJyb3IgYXMgSSwgSW50bEVycm9yQ29kZSBhcyBhLCBjcmVhdGVJbnRsRm9ybWF0dGVycyBhcyBiLCBjcmVhdGVGb3JtYXR0ZXIgYXMgYywgY3JlYXRlQ2FjaGUgYXMgZCwgY3JlYXRlQmFzZVRyYW5zbGF0b3IgYXMgZSwgZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayBhcyBmLCBkZWZhdWx0T25FcnJvciBhcyBnLCBpbml0aWFsaXplQ29uZmlnIGFzIGksIHJlc29sdmVOYW1lc3BhY2UgYXMgciB9O1xuIl0sIm5hbWVzIjpbIkludGxNZXNzYWdlRm9ybWF0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJtZW1vaXplIiwic3RyYXRlZ2llcyIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsIkludGxFcnJvckNvZGUiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJnbG9iYWxGb3JtYXRzIiwiaW5saW5lRm9ybWF0cyIsInRpbWVab25lIiwibWZEYXRlRGVmYXVsdHMiLCJmb3JtYXRzIiwiZGF0ZSIsIm1mVGltZURlZmF1bHRzIiwidGltZSIsImRhdGVUaW1lRm9ybWF0cyIsImRhdGVUaW1lIiwiYWxsRm9ybWF0cyIsIm51bWJlciIsImZvckVhY2giLCJwcm9wZXJ0eSIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsImpvaW5QYXRoIiwicGFydHMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsImRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2siLCJwcm9wcyIsIm5hbWVzcGFjZSIsImRlZmF1bHRPbkVycm9yIiwiZXJyb3IiLCJjb25zb2xlIiwiY3JlYXRlQ2FjaGUiLCJyZWxhdGl2ZVRpbWUiLCJwbHVyYWxSdWxlcyIsImxpc3QiLCJkaXNwbGF5TmFtZXMiLCJjcmVhdGVNZW1vQ2FjaGUiLCJzdG9yZSIsImNyZWF0ZSIsImdldCIsInNldCIsIm1lbW9GbiIsImZuIiwiY2FjaGUiLCJzdHJhdGVneSIsInZhcmlhZGljIiwibWVtb0NvbnN0cnVjdG9yIiwiQ29uc3RydWN0b3JGbiIsImFyZ3MiLCJjcmVhdGVJbnRsRm9ybWF0dGVycyIsImdldERhdGVUaW1lRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiZ2V0TnVtYmVyRm9ybWF0IiwiTnVtYmVyRm9ybWF0IiwiZ2V0UGx1cmFsUnVsZXMiLCJQbHVyYWxSdWxlcyIsImdldFJlbGF0aXZlVGltZUZvcm1hdCIsIlJlbGF0aXZlVGltZUZvcm1hdCIsImdldExpc3RGb3JtYXQiLCJMaXN0Rm9ybWF0IiwiZ2V0RGlzcGxheU5hbWVzIiwiRGlzcGxheU5hbWVzIiwiY3JlYXRlTWVzc2FnZUZvcm1hdHRlciIsImludGxGb3JtYXR0ZXJzIiwiZ2V0TWVzc2FnZUZvcm1hdCIsImZvcm1hdHRlcnMiLCJyZXNvbHZlUGF0aCIsImxvY2FsZSIsIm1lc3NhZ2VzIiwiZnVsbEtleSIsInNwbGl0IiwicGFydCIsIm5leHQiLCJwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJ0cmFuc2Zvcm1lZFZhbHVlcyIsImtleXMiLCJpbmRleCIsInRyYW5zZm9ybWVkIiwiY2h1bmtzIiwicmVzdWx0IiwiZ2V0TWVzc2FnZXNPckVycm9yIiwib25FcnJvciIsInJldHJpZXZlZE1lc3NhZ2VzIiwiaW50bEVycm9yIiwiTUlTU0lOR19NRVNTQUdFIiwiZ2V0UGxhaW5NZXNzYWdlIiwiY2FuZGlkYXRlIiwidGVzdCIsInVuZGVmaW5lZCIsImNyZWF0ZUJhc2VUcmFuc2xhdG9yIiwiY29uZmlnIiwibWVzc2FnZXNPckVycm9yIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwiaGFzTWVzc2FnZXNFcnJvciIsImdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5IiwidHJhbnNsYXRlQmFzZUZuIiwiZXJyb3JNZXNzYWdlIiwiQXJyYXkiLCJpc0FycmF5IiwiSU5WQUxJRF9NRVNTQUdFIiwiSU5TVUZGSUNJRU5UX1BBVEgiLCJtZXNzYWdlRm9ybWF0IiwicGxhaW5NZXNzYWdlIiwibG9jYWxlcyIsIm9wdGlvbnMiLCJ0aHJvd25FcnJvciIsImZvcm1hdHRlZE1lc3NhZ2UiLCJmb3JtYXQiLCJTdHJpbmciLCJGT1JNQVRUSU5HX0VSUk9SIiwidHJhbnNsYXRlRm4iLCJyaWNoIiwibWFya3VwIiwicmF3IiwiaGFzIiwicmVzb2x2ZU5hbWVzcGFjZSIsIm5hbWVzcGFjZVByZWZpeCIsInNsaWNlIiwibGVuZ3RoIiwiU0VDT05EIiwiTUlOVVRFIiwiSE9VUiIsIkRBWSIsIldFRUsiLCJNT05USCIsIlFVQVJURVIiLCJZRUFSIiwiVU5JVF9TRUNPTkRTIiwic2Vjb25kIiwic2Vjb25kcyIsIm1pbnV0ZSIsIm1pbnV0ZXMiLCJob3VyIiwiaG91cnMiLCJkYXkiLCJkYXlzIiwid2VlayIsIndlZWtzIiwibW9udGgiLCJtb250aHMiLCJxdWFydGVyIiwicXVhcnRlcnMiLCJ5ZWFyIiwieWVhcnMiLCJyZXNvbHZlUmVsYXRpdmVUaW1lVW5pdCIsImFic1ZhbHVlIiwiTWF0aCIsImFicyIsImNhbGN1bGF0ZVJlbGF0aXZlVGltZVZhbHVlIiwidW5pdCIsInJvdW5kIiwiY3JlYXRlRm9ybWF0dGVyIiwiX2NhY2hlIiwiX2Zvcm1hdHRlcnMiLCJnbG9iYWxUaW1lWm9uZSIsImFwcGx5VGltZVpvbmUiLCJFTlZJUk9OTUVOVF9GQUxMQkFDSyIsInJlc29sdmVGb3JtYXRPck9wdGlvbnMiLCJ0eXBlRm9ybWF0cyIsImZvcm1hdE9yT3B0aW9ucyIsIm92ZXJyaWRlcyIsImZvcm1hdE5hbWUiLCJNSVNTSU5HX0ZPUk1BVCIsImdldEZvcm1hdHRlZFZhbHVlIiwiZm9ybWF0dGVyIiwiZ2V0RmFsbGJhY2siLCJkYXRlVGltZVJhbmdlIiwic3RhcnQiLCJlbmQiLCJmb3JtYXRSYW5nZSIsImdldEdsb2JhbE5vdyIsIm5vdyIsIkRhdGUiLCJub3dPck9wdGlvbnMiLCJub3dEYXRlIiwib3B0cyIsInN0eWxlIiwibnVtYmVyaW5nU3lzdGVtIiwiZGF0ZURhdGUiLCJnZXRUaW1lIiwibnVtZXJpYyIsInNlcmlhbGl6ZWRWYWx1ZSIsInJpY2hWYWx1ZXMiLCJNYXAiLCJpdGVtIiwic2VyaWFsaXplZEl0ZW0iLCJwdXNoIiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJzaXplIiwidmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQiLCJpbnZhbGlkS2V5TGFiZWxzIiwicGFyZW50UGF0aCIsIm1lc3NhZ2VPck1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJrZXlMYWJlbCIsInZhbGlkYXRlTWVzc2FnZXMiLCJJTlZBTElEX0tFWSIsImluaXRpYWxpemVDb25maWciLCJyZXN0IiwiZmluYWxPbkVycm9yIiwiZmluYWxHZXRNZXNzYWdlRmFsbGJhY2siLCJJIiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImkiLCJyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/esm/development/initializeConfig-DPFnvsUO.js\n");

/***/ })

};
;